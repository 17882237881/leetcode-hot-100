# 3. 无重复字符的最长子串

## 题目描述
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

## 示例
```
示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

## 约束条件
- 0 <= s.length <= 5 * 10^4
- `s` 由英文字母、数字、符号和空格组成。

## 思考过程

### 🤔 第一步：理解问题
- 我们要找的是 **子串**，意味着字符必须是连续的。
- 这个子串必须 **没有重复字符**。
- 我们需要返回的是满足条件的最长子串的 **长度**。

### 🤔 第二步：暴力解法
最直接的想法是，找出所有的子串，然后逐一检查它们是否含有重复字符，并记录最长的长度。

**思考题：**
- 如何用循环实现找到所有子串？
- 如何检查一个子串是否有重复字符？
- 这个方法的时间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 可以用两层循环，`i` 从 0 到 n-1，`j` 从 `i` 到 n-1，来生成所有子串 `s[i:j+1]`。
- 对于每个子串，可以再用一个哈希集合（Set）来检查是否有重复字符，这需要 O(L) 的时间，其中 L 是子串长度。
- 总时间复杂度大约是 O(n³)，对于 `n <= 5 * 10^4` 来说，是完全无法接受的。

</details>

### 🤔 第三步：寻找优化思路 -> 滑动窗口
暴力解法做了太多重复的检查。例如，当我们检查完 `"abc"` 后，再检查 `"abca"` 时，我们其实不需要从头开始。我们知道 `"abc"` 是无重复的，问题出在最后一个 `'a'` 上。

这启发我们使用一种更聪明的移动方式来扫描字符串，这就是 **滑动窗口**。

想象一个窗口在字符串上滑动。这个窗口代表我们当前正在考察的子串。
- 我们需要一个 **右指针 `right`**，负责扩大窗口，将新字符纳入考察范围。
- 我们需要一个 **左指针 `left`**，在窗口内出现重复字符时，负责收缩窗口，将重复的源头排除出去。
- 我们还需要一个数据结构（比如哈希集合或哈希表）来快速判断窗口内是否存在某个字符。

### 🤔 第四步：滑动窗口算法
1. 初始化 `left = 0`, `right = 0`，`max_len = 0`。
2. 用一个哈希集合 `window_chars` 来存储当前窗口内的所有字符。
3. 当 `right` 指针没有越界时，循环执行：
   a. 将 `s[right]` 字符移入窗口。
   b. **检查 `s[right]` 是否已经在 `window_chars` 中？**
      - **如果不在**：说明当前窗口仍然没有重复字符。我们将 `s[right]` 加入 `window_chars`，然后更新 `max_len = max(max_len, right - left + 1)`。之后，移动 `right` 指针，扩大窗口 (`right++`)。
      - **如果在**：说明 `s[right]` 与窗口中的某个字符重复了。我们需要收缩窗口。我们将 `s[left]` 从 `window_chars` 中移除，然后移动 `left` 指针 (`left++`)。我们**持续**这个收缩过程，直到 `s[right]` 这个重复的源头被移除出窗口左侧为止。

**优化一下逻辑：**
上面的收缩逻辑可以更清晰地表述为：

当 `s[right]` 已经在 `window_chars` 中时，我们就进入一个 `while` 循环，不断地从窗口左侧移除字符 `s[left]` 并 `left++`，直到 `s[right]` 不再是重复项为止。然后才将新的 `s[right]` 加入窗口。

**再优化一下：**
我们可以用哈希表（字典）来代替哈希集合，存储每个字符及其最新的索引。`window[char] = index`。

- 当我们遇到一个新字符 `s[right]` 时，如果它已经在 `window` 中，并且它的旧索引 `window[s[right]]` 大于等于我们当前的左边界 `left`，这意味着在当前窗口内发生了重复。
- 此时，我们不需要一步步地移动 `left`，而是可以直接将 `left` **跳**到重复字符的旧位置的**下一个位置**：`left = window[s[right]] + 1`。
- 无论是否重复，我们都更新 `s[right]` 的最新索引到哈希表中，并计算当前窗口长度 `right - left + 1`，更新最大长度。

### 🤔 第五步：算法步骤总结（优化后）
1. 初始化一个哈希表 `window` 用于存储字符的最新索引，`left = 0`，`max_len = 0`。
2. 用 `right` 指针遍历字符串 `s`（从 0 到 n-1）：
   a. 获取当前字符 `char = s[right]`。
   b. **检查重复**：如果 `char` 在 `window` 中，并且 `window[char] >= left`，说明在当前窗口 `[left, right]` 内发现重复。更新左边界 `left = window[char] + 1`。
   c. **更新索引**：将 `char` 的最新索引存入 `window`：`window[char] = right`。
   d. **更新结果**：计算当前无重复子串的长度 `right - left + 1`，并更新 `max_len`。
3. 遍历结束后，返回 `max_len`。

**时间复杂度：** O(n) - 因为 `left` 和 `right` 指针都只从左到右遍历一次字符串。
**空间复杂度：** O(k) - 其中 k 是字符串中不同字符的数量。最坏情况下，所有字符都不同，空间复杂度为 O(n)。

## 代码实现

### Python
```python
def lengthOfLongestSubstring(s: str) -> int:
    """
    使用滑动窗口和哈希表寻找最长无重复子串的长度。
    """
    if not s:
        return 0
    
    # window 用来存储字符及其最新出现的索引
    window = {}
    max_len = 0
    left = 0  # 窗口的左边界
    
    # right 是窗口的右边界
    for right, char in enumerate(s):
        # 检查字符是否在当前窗口内重复
        # 如果 char 在 window 中，并且它的索引在 left 右侧（或重合），说明重复
        if char in window and window[char] >= left:
            # 发现重复，将左边界直接移动到重复字符的下一个位置
            left = window[char] + 1
        
        # 无论如何，都更新字符的最新位置
        window[char] = right
        
        # 计算当前窗口的长度，并更新最大长度
        current_len = right - left + 1
        max_len = max(max_len, current_len)
        
    return max_len

```

## 关键点总结
1. **滑动窗口**：是解决一系列子串问题的通用高效思想，避免了暴力解法的冗余计算。
2. **哈希表/集合**：是滑动窗口的得力助手，用于快速判断窗口内的元素情况（是否存在、出现次数、最新位置等）。
3. **指针移动策略**：
   - 右指针 `right` 总是向右移动，用于扩展窗口。
   - 左指针 `left` 只在需要收缩窗口时移动，并且优化后的算法可以让它“跳跃”而不是“爬行”，从而提高效率。
