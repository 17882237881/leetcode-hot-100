**394. 字符串解码**

**思考过程:**

这道题要求解码一个字符串，其中包含用数字和方括号表示的重复子字符串。例如，`"3[a]2[bc]"` 解码为 `"aaabcbc"`。

**核心思路:**

这道题可以使用栈来解决。当遇到数字时，我们将其压入一个栈（用于存储重复次数）；当遇到左括号时，我们将其压入另一个栈（用于存储当前字符串）。当遇到右括号时，我们弹出栈顶的重复次数和字符串，进行解码，并将解码后的字符串重新压入字符串栈。

**具体步骤:**

我们可以使用两个栈：
1.  `num_stack`: 存储数字（重复次数）。
2.  `str_stack`: 存储字符串（在遇到 `[` 之前已经构建好的字符串）。

同时，我们需要一个 `current_num` 来构建当前数字，一个 `current_str` 来构建当前字符串。

**遍历字符串 `s`:**

-   **如果 `char` 是数字:** 将 `char` 转换为数字并更新 `current_num = current_num * 10 + int(char)`。
-   **如果 `char` 是 `[`:**
    -   将 `current_str` 压入 `str_stack`。
    -   将 `current_num` 压入 `num_stack`。
    -   重置 `current_str = ""`。
    -   重置 `current_num = 0`。
-   **如果 `char` 是 `]`:**
    -   从 `num_stack` 弹出 `repeat_times`。
    -   从 `str_stack` 弹出 `prev_str`。
    -   `current_str = prev_str + current_str * repeat_times`。
-   **如果 `char` 是字母:** 将 `char` 添加到 `current_str`。

**最后，返回 `current_str`。**

**Python 代码:**

```python
class Solution:
    def decodeString(self, s: str) -> str:
        num_stack = []
        str_stack = []
        current_num = 0
        current_str = ""

        for char in s:
            if '0' <= char <= '9':
                current_num = current_num * 10 + int(char)
            elif char == '[':
                num_stack.append(current_num)
                str_stack.append(current_str)
                current_num = 0
                current_str = ""
            elif char == ']':
                repeat_times = num_stack.pop()
                prev_str = str_stack.pop()
                current_str = prev_str + current_str * repeat_times
            else: # 字母
                current_str += char
        
        return current_str
```
