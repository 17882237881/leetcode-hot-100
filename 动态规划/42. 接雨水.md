# 42. 接雨水

## 题目描述

给定 `n` 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分所示）。
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

*   `n == height.length`
*   `1 <= n <= 2 * 10^4`
*   `0 <= height[i] <= 10^5`

---

## 解题引导

### 思路：动态规划

**思考过程：**

对于每个柱子，它能接的雨水量取决于其左右两侧最高的柱子中的较小者。具体来说，对于位置 `i` 的柱子，它能接的雨水高度等于 `min(左侧最高柱子高度, 右侧最高柱子高度) - height[i]`。当然，这个值必须大于 0。

为了高效地计算每个位置的左右两侧最高柱子，我们可以使用动态规划。

**状态定义：**

*   `left_max[i]`：表示从左到右，到位置 `i` 为止（包括 `i`）的最高柱子高度。
*   `right_max[i]`：表示从右到左，到位置 `i` 为止（包括 `i`）的最高柱子高度。

**状态转移方程：**

*   `left_max[i] = max(left_max[i-1], height[i])`
*   `right_max[i] = max(right_max[i+1], height[i])`

**算法流程：**

1.  创建两个数组 `left_max` 和 `right_max`，长度与 `height` 相同。
2.  **第一次遍历（从左到右）：** 计算 `left_max` 数组。
    *   `left_max[0] = height[0]`
    *   从 `i = 1` 到 `n-1`，`left_max[i] = max(left_max[i-1], height[i])`。
3.  **第二次遍历（从右到左）：** 计算 `right_max` 数组。
    *   `right_max[n-1] = height[n-1]`
    *   从 `i = n-2` 到 `0`，`right_max[i] = max(right_max[i+1], height[i])`。
4.  **第三次遍历：** 计算总雨水量。
    *   初始化 `total_water = 0`。
    *   遍历每个位置 `i`（从 `0` 到 `n-1`）：
        *   在位置 `i`，水能达到的高度是 `min(left_max[i], right_max[i])`。
        *   该位置能接的雨水量是 `min(left_max[i], right_max[i]) - height[i]`。
        *   将这个水量累加到 `total_water`。
5.  返回 `total_water`。

**复杂度分析：**

*   **时间复杂度：** `O(n)`。我们需要三次线性遍历。
*   **空间复杂度：** `O(n)`。需要两个额外的数组 `left_max` 和 `right_max` 来存储状态。

---

## Python 代码实现

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        n = len(height)
        if n <= 2:
            return 0

        # left_max[i] 表示从左到右到 i 的最大高度
        left_max = [0] * n
        left_max[0] = height[0]
        for i in range(1, n):
            left_max[i] = max(left_max[i-1], height[i])

        # right_max[i] 表示从右到左到 i 的最大高度
        right_max = [0] * n
        right_max[n-1] = height[n-1]
        for i in range(n-2, -1, -1):
            right_max[i] = max(right_max[i+1], height[i])

        total_water = 0
        # 遍历每个柱子，计算能接的雨水
        for i in range(n):
            # 决定水面的高度
            water_level = min(left_max[i], right_max[i])
            # 计算当前柱子能接的雨水
            total_water += water_level - height[i]

        return total_water

```