# 32. 最长有效括号

## 题目描述

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

**提示：**

*   `0 <= s.length <= 3 * 10^4`
*   `s[i]` 为 `'('` 或 `')'`

---

## 解题引导

### 思路：动态规划

**思考过程：**

这个问题要求找到最长的格式正确的括号子串。我们可以使用动态规划来解决。

关键在于如何定义 `dp` 数组以及如何找到状态转移关系。

**状态定义：**
`dp[i]`：表示以 `s[i]` **结尾** 的最长有效括号子串的长度。

**状态转移方程：**

我们需要遍历字符串 `s`，并根据 `s[i]` 的字符来更新 `dp` 数组。

1.  如果 `s[i] == '('`：
    以左括号结尾的子串不可能是有效的括号串，所以 `dp[i] = 0`。

2.  如果 `s[i] == ')'`：
    这是复杂的部分，我们需要考虑 `s[i-1]` 的情况：

    *   **情况一：`s[i-1] == '('`**
        这种形式是 `...()`。`s[i]` 和 `s[i-1]` 组成了一对有效的括号 `()`。这个 `()` 可以和它前面的有效括号子串连接起来。前面的有效子串是以 `s[i-2]` 结尾的，其长度为 `dp[i-2]`。
        所以，`dp[i] = dp[i-2] + 2`。（需要注意 `i-2` 的边界）

    *   **情况二：`s[i-1] == ')'`**
        这种形式是 `...))`。为了让 `s[i]` 能够匹配，我们需要在它前面找到一个对应的 `'('`。这个 `'('` 的位置在哪里呢？
        如果 `s[i-1]` 是一个有效子串的结尾，这个子串的长度是 `dp[i-1]`。那么这个子串开始的位置是 `i - 1 - dp[i-1] + 1 = i - dp[i-1]`。我们需要看这个子串前面的一个字符，即 `s[i - dp[i-1] - 1]`。
        *   如果 `i - dp[i-1] - 1` 是一个有效的位置，并且 `s[i - dp[i-1] - 1] == '('`，那么我们就找到了一个匹配。这个匹配的括号对 `(...)` 包裹了 `s[i-dp[i-1]...i-1]` 这个有效子串。新的有效子串长度是 `dp[i-1] + 2`。
        *   还没完！这个新形成的 `(...)` 可能还可以和它前面的有效子串连接起来。这个前面的有效子串是以 `s[i - dp[i-1] - 2]` 结尾的。所以我们还要加上 `dp[i - dp[i-1] - 2]`。
        *   总的长度为 `dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]`。（需要注意边界）

**最终结果：**

最长的有效括号子串不一定以最后一个字符结尾，所以最终结果是整个 `dp` 数组中的最大值。

**算法流程：**

1.  创建一个和 `s` 等长的 `dp` 数组，并全部初始化为 0。
2.  初始化一个变量 `max_len = 0` 来记录最大长度。
3.  遍历字符串 `s` 从 `i = 1` 到 `n-1`。
4.  根据 `s[i]` 的值和上述的状态转移逻辑来计算 `dp[i]`。
5.  每次计算完 `dp[i]` 后，更新 `max_len = max(max_len, dp[i])`。
6.  遍历结束后，返回 `max_len`。

**复杂度分析：**

*   **时间复杂度：** `O(n)`。我们只遍历字符串一次。
*   **空间复杂度：** `O(n)`。需要一个 `dp` 数组来存储状态。

---

## Python 代码实现

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        n = len(s)
        if n < 2:
            return 0
        
        # dp[i] 表示以 s[i] 结尾的最长有效括号的长度
        dp = [0] * n
        max_len = 0
        
        for i in range(1, n):
            if s[i] == ')':
                # 情况一: ...()
                if s[i-1] == '(':
                    # 如果 i-2 >= 0，则可以连接前面的有效子串
                    dp[i] = (dp[i-2] if i >= 2 else 0) + 2
                # 情况二: ...))
                # i - dp[i-1] - 1 是需要匹配的 '(' 的位置
                elif i - dp[i-1] > 0 and s[i - dp[i-1] - 1] == '(':
                    # dp[i-1] 是内部 ...)) 中第一个 ) 结尾的有效长度
                    # +2 是外层的 ()
                    # dp[i - dp[i-1] - 2] 是更前面的有效子串长度
                    prev_len = dp[i - dp[i-1] - 2] if i - dp[i-1] >= 2 else 0
                    dp[i] = dp[i-1] + 2 + prev_len
            
            max_len = max(max_len, dp[i])
            
        return max_len

```