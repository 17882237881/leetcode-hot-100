# 416. 分割等和子集

## 题目描述

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**提示：**

*   `1 <= nums.length <= 200`
*   `1 <= nums[i] <= 100`

---

## 解题引导

### 思路：动态规划（0-1 背包问题）

**思考过程：**

这个问题可以转化为一个经典的组合优化问题——**0-1 背包问题**。

首先，如果整个数组的元素总和 `sum` 是一个奇数，那么我们不可能把它分割成两个和相等的子集，因为子集的和必须是 `sum / 2`，而 `sum / 2` 不是整数。所以，如果 `sum` 是奇数，直接返回 `false`。

如果 `sum` 是偶数，我们的目标就变成了：**是否能从数组 `nums` 中挑选出一些数，使得这些数的和恰好等于 `target = sum / 2`**。

这正是 0-1 背包问题的模型：
*   **背包的容量**：`target = sum / 2`
*   **物品**：数组 `nums` 中的每一个元素 `num`
*   **物品的重量（和价值）**：元素 `num` 的值

我们需要判断是否能恰好装满这个背包。

**状态定义：**
`dp[i]`：一个布尔值，表示是否存在 `nums` 的一个子集，其和为 `i`。

**状态转移方程：**

我们遍历 `nums` 中的每一个数字 `num`。对于每个 `num`，我们更新 `dp` 数组。我们从后往前遍历 `dp` 数组（从 `target` 到 `num`），以避免一个 `num` 被重复使用。

对于当前的 `dp[i]`，它可能为 `true` 的情况有两种：
1.  在不考虑 `num` 的情况下，`dp[i]` 本身就已经是 `true`。
2.  在不考虑 `num` 的情况下，`dp[i - num]` 是 `true`，那么我们只要把 `num` 加入那个和为 `i - num` 的子集，就能得到和为 `i` 的新子集。

所以，状态转移方程是：
`dp[i] = dp[i] or dp[i - num]`

**为什么需要从后往前遍历？**

如果我们从前往后遍历 `i`，当我们计算 `dp[i]` 时，`dp[i - num]` 可能已经被当前的 `num` 更新过了。例如，`num=2`，`target=4`。如果从前往后，`dp[2]` 会因为 `dp[0]` 而变为 `true`，然后 `dp[4]` 会因为 `dp[2]` 而变为 `true`。这相当于数字 2 被使用了两次，而 0-1 背包中每个物品只能用一次。

**边界条件（初始化）：**

*   `dp[0] = true`：和为 0 的子集是存在的（即空集）。
*   其余 `dp[i]` 初始化为 `false`。

**最终结果：**

我们最终的目标是判断是否存在和为 `target` 的子集，所以返回 `dp[target]`。

**算法流程：**

1.  计算数组总和 `sum`。如果 `sum` 是奇数，返回 `false`。
2.  计算目标和 `target = sum // 2`。
3.  创建一个大小为 `target + 1` 的布尔数组 `dp`，初始化 `dp[0] = true`。
4.  遍历 `nums` 中的每个数字 `num`。
5.  对于每个 `num`，内层循环从 `target` 向下遍历到 `num`。
6.  应用状态转移方程 `dp[i] = dp[i] or dp[i - num]`。
7.  遍历结束后，返回 `dp[target]`。

**复杂度分析：**

*   **时间复杂度：** `O(n * target)`，其中 `n` 是数组 `nums` 的长度，`target` 是目标和。
*   **空间复杂度：** `O(target)`。需要一个 `dp` 数组。

---

## Python 代码实现

```python
class Solution:
    def canPartition(self, nums: list[int]) -> bool:
        total_sum = sum(nums)
        
        # 如果总和是奇数，不可能分割成两个相等的子集
        if total_sum % 2 != 0:
            return False
            
        target = total_sum // 2
        
        # dp[i] 表示是否存在和为 i 的子集
        dp = [False] * (target + 1)
        dp[0] = True
        
        for num in nums:
            # 从后往前遍历，避免重复使用同一个数字
            for i in range(target, num - 1, -1):
                dp[i] = dp[i] or dp[i - num]
                
        return dp[target]

```