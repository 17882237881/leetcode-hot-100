# 322. 零钱兑换

## 题目描述

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**提示：**

*   `1 <= coins.length <= 12`
*   `1 <= coins[i] <= 2^31 - 1`
*   `0 <= amount <= 10^4`

---

## 解题引导

### 思路：动态规划

**思考过程：**

这个问题要求我们用最少的硬币凑出指定的金额，这是一个典型的动态规划问题，具体来说是“完全背包”问题求最小值。

我们的目标是求凑成金额 `amount` 所需的最少硬币数。

**状态定义：**
`dp[i]`：表示凑成金额 `i` 所需要的最少硬币数量。

**状态转移方程：**

为了计算 `dp[i]`，我们可以考虑最后一枚硬币是什么。假设最后一枚硬币的面额是 `coin`（`coin` 是 `coins` 数组中的一个元素）。

那么，凑成金额 `i` 的最少硬币数，就等于凑成金额 `i - coin` 的最少硬币数 `dp[i - coin]` 再加上这枚 `coin`（即 `+1`）。

因为我们有多种面额的硬币可以选择，所以我们需要遍历所有硬币面额 `coin`，并从中找到能使 `dp[i]` 最小的那个选择。

所以，状态转移方程是：
`dp[i] = min(dp[i - coin]) + 1`，其中 `coin` 是 `coins` 中的所有面额，且 `i >= coin`。

**边界条件（初始化）：**

*   `dp[0] = 0`：凑成金额 0 需要 0 个硬币。
*   对于其他 `dp[i]`（`i > 0`），我们应该初始化为一个“无穷大”的值（比如 `amount + 1`，因为硬币数量不可能超过 `amount`），表示初始时无法凑成。这样在取 `min` 的时候，任何一个有效的方案都会比这个初始值小。

**最终结果：**

我们要求的是凑成金额 `amount` 的最少硬币数，即 `dp[amount]`。
如果 `dp[amount]` 的值仍然是我们初始化的“无穷大”，说明无法凑成该金额，返回 -1。

**算法流程：**

1.  创建一个大小为 `amount + 1` 的 `dp` 数组。
2.  初始化 `dp[0] = 0`，其余元素初始化为 `amount + 1`。
3.  外层循环遍历金额 `i` 从 1 到 `amount`。
4.  内层循环遍历所有硬币面额 `coin`。
5.  如果 `i >= coin`，则应用状态转移方程更新 `dp[i] = min(dp[i], dp[i - coin] + 1)`。
6.  遍历结束后，如果 `dp[amount] > amount`，返回 -1，否则返回 `dp[amount]`。

**复杂度分析：**

*   **时间复杂度：** `O(S * n)`，其中 `S` 是总金额 `amount`，`n` 是硬币 `coins` 的种类数。我们需要两层循环来填充 `dp` 数组。
*   **空间复杂度：** `O(S)`。我们需要一个 `dp` 数组来存储从 0 到 `amount` 的所有子问题的解。

---

## Python 代码实现

```python
class Solution:
    def coinChange(self, coins: list[int], amount: int) -> int:
        # dp[i] 表示凑成金额 i 所需的最少硬币数
        # 初始化为一个大数，amount + 1 即可，因为硬币数最多为 amount
        dp = [amount + 1] * (amount + 1)
        dp[0] = 0
        
        for i in range(1, amount + 1):
            for coin in coins:
                if i >= coin:
                    dp[i] = min(dp[i], dp[i - coin] + 1)
                    
        # 如果 dp[amount] 还是初始值，说明无解
        return dp[amount] if dp[amount] <= amount else -1

```