# 152. 乘积最大子数组

## 题目描述

给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

**示例 1:**

```
输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

**提示:**

*   `1 <= nums.length <= 2 * 10^4`
*   `-10 <= nums[i] <= 10`
*   `nums` 的任何前缀或后缀的乘积都保证是一个 32-bit 整数

---

## 解题引导

### 思路：动态规划

**思考过程：**

这个问题与“最大子数组和”类似，但由于乘法中负数的存在，情况变得复杂。一个负数乘以一个负数会得到正数，所以我们不仅要关心当前的最大值，还要关心当前的最小值（因为它可能是一个负数，再乘以一个负数就可能成为最大值）。

因此，在遍历数组时，我们需要同时维护两个状态：
1.  以当前元素 `nums[i]` 结尾的**最大**乘积。
2.  以当前元素 `nums[i]` 结尾的**最小**乘积。

**状态定义：**
*   `max_dp[i]`：表示以 `nums[i]` 结尾的连续子数组的最大乘积。
*   `min_dp[i]`：表示以 `nums[i]` 结尾的连续子数组的最小乘积。

**状态转移方程：**

当我们考虑 `nums[i]` 时，以它结尾的最大乘积可能有三种来源：
1.  `max_dp[i-1] * nums[i]`：前一个最大乘积乘以当前数。
2.  `min_dp[i-1] * nums[i]`：前一个最小乘积（可能是负数）乘以当前数（如果是负数）。
3.  `nums[i]`：当前数自身。

所以，状态转移方程是：
`max_dp[i] = max(max_dp[i-1] * nums[i], min_dp[i-1] * nums[i], nums[i])`
`min_dp[i] = min(max_dp[i-1] * nums[i], min_dp[i-1] * nums[i], nums[i])`

**最终结果：**

全局的最大乘积不一定在最后产生，它可能是任何一个 `max_dp[i]`。所以我们需要一个变量 `max_product` 来记录整个过程中的最大值。

**空间优化：**

`max_dp[i]` 和 `min_dp[i]` 的计算只依赖于 `max_dp[i-1]` 和 `min_dp[i-1]`。因此，我们可以用两个变量 `current_max` 和 `current_min` 来代替 `dp` 数组，将空间复杂度从 `O(n)` 优化到 `O(1)`。

**算法流程（优化后）：**

1.  初始化 `max_product`, `current_max`, `current_min` 都为 `nums[0]`。
2.  从数组的第二个元素开始遍历（`i` 从 1 到 `n-1`）。
3.  在循环中，如果 `nums[i]` 是负数，交换 `current_max` 和 `current_min` 的值。因为乘以一个负数会让最大值变最小值，最小值变最大值。
4.  更新 `current_max = max(nums[i], current_max * nums[i])`。
5.  更新 `current_min = min(nums[i], current_min * nums[i])`。
6.  更新 `max_product = max(max_product, current_max)`。
7.  遍历结束后，返回 `max_product`。

**复杂度分析（优化后）：**

*   **时间复杂度：** `O(n)`。一次遍历数组。
*   **空间复杂度：** `O(1)`。只使用常数个变量。

---

## Python 代码实现 (空间优化)

```python
class Solution:
    def maxProduct(self, nums: list[int]) -> int:
        if not nums:
            return 0
        
        max_product = nums[0]
        current_max = nums[0]
        current_min = nums[0]
        
        for i in range(1, len(nums)):
            # 当遇到负数时，最大值和最小值会互换
            if nums[i] < 0:
                current_max, current_min = current_min, current_max
            
            # 更新以当前元素结尾的最大和最小乘积
            current_max = max(nums[i], current_max * nums[i])
            current_min = min(nums[i], current_min * nums[i])
            
            # 更新全局最大乘积
            max_product = max(max_product, current_max)
            
        return max_product

```