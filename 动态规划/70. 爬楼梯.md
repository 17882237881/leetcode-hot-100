# 70. 爬楼梯

## 题目描述

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：** 给定 `n` 是一个正整数。

**示例 1：**

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```

**示例 2：**

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

---

## 解题引导

### 思路：动态规划

**思考过程：**

这是一个经典的动态规划问题。我们要求的是爬到第 `n` 阶楼梯的方法数。

让我们来分析一下问题。要想到达第 `n` 阶，我们最后一步是怎么走的？
*   可能是从第 `n-1` 阶爬了 `1` 个台阶上来的。
*   也可能是从第 `n-2` 阶爬了 `2` 个台阶上来的。

所以，到达第 `n` 阶的方法数，等于到达第 `n-1` 阶的方法数与到达第 `n-2` 阶的方法数之和。这不就是斐波那契数列吗？

**状态定义：**
`dp[i]`：表示爬到第 `i` 阶楼梯的不同方法数。

**状态转移方程：**
`dp[i] = dp[i-1] + dp[i-2]`

**边界条件：**
*   `dp[1] = 1` （爬到第 1 阶只有一种方法：爬 1 阶）
*   `dp[2] = 2` （爬到第 2 阶有两种方法：1+1 或 2）

**算法流程：**

1.  创建一个大小为 `n+1` 的数组 `dp` 来存储到达每一阶的方法数。
2.  初始化边界条件 `dp[1] = 1` 和 `dp[2] = 2`。
3.  从 `i = 3` 开始遍历到 `n`，根据状态转移方程 `dp[i] = dp[i-1] + dp[i-2]` 计算 `dp[i]`。
4.  最终返回 `dp[n]`。

**空间优化：**

注意到 `dp[i]` 的计算只依赖于 `dp[i-1]` 和 `dp[i-2]`，所以我们不需要一个完整的 `dp` 数组，只需要两个变量来记录前两个状态即可。这可以将空间复杂度从 `O(n)` 优化到 `O(1)`。

**复杂度分析（优化后）：**

*   **时间复杂度：** `O(n)`。我们需要循环 `n` 次来计算结果。
*   **空间复杂度：** `O(1)`。我们只使用了常数个变量。

---

## Python 代码实现

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        if n <= 2:
            return n
        
        # 使用两个变量来代替 dp 数组，优化空间
        prev1 = 1  # dp[i-1]
        prev2 = 2  # dp[i]
        
        for i in range(3, n + 1):
            current = prev1 + prev2
            prev1 = prev2
            prev2 = current
            
        return prev2

```