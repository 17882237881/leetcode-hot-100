# 139. 单词拆分

## 题目描述

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

**提示：**

*   `1 <= s.length <= 300`
*   `1 <= wordDict.length <= 1000`
*   `1 <= wordDict[i].length <= 20`
*   `s` 和 `wordDict[i]` 仅由小写英文字母组成
*   `wordDict` 中的所有字符串 **互不相同**

---

## 解题引导

### 思路：动态规划

**思考过程：**

这个问题要求我们判断一个字符串能否被字典中的单词完全拼接而成。这是一个典型的“完全背包”问题变种，可以用动态规划来解决。

我们需要判断字符串 `s` 的前缀子串是否能被成功拆分。

**状态定义：**
`dp[i]`：一个布尔值，表示字符串 `s` 中长度为 `i` 的前缀 `s[0...i-1]` 是否可以被 `wordDict` 中的单词拼接而成。

**状态转移方程：**

为了计算 `dp[i]`，我们需要考虑 `s[0...i-1]` 的最后一个单词是什么。我们遍历所有可能的分割点 `j`（`0 <= j < i`），将字符串 `s[0...i-1]` 分为两部分：`s[0...j-1]` 和 `s[j...i-1]`。

如果 `s[0...j-1]` 可以被成功拆分（即 `dp[j]` 为 `true`），并且 `s[j...i-1]` 这个子串本身就在字典 `wordDict` 中，那么 `s[0...i-1]` 就可以被成功拆分，`dp[i]` 就为 `true`。

只要我们能找到任何一个这样的 `j`，就可以确定 `dp[i]` 为 `true`。

所以，状态转移方程是：
`dp[i] = OR(dp[j] and s[j...i-1] in wordDict)` for `0 <= j < i`

**边界条件（初始化）：**

`dp[0] = true`。这表示一个空字符串（长度为 0 的前缀）可以被“拆分”，这是一个计算的起点。

**最终结果：**

我们要求的是整个字符串 `s`（即长度为 `n` 的前缀）是否能被拆分，所以结果是 `dp[n]`。

**算法流程：**

1.  为了快速查询单词，将 `wordDict` 转换为一个哈希集合。
2.  创建一个大小为 `n+1` 的布尔数组 `dp`，`n` 是字符串 `s` 的长度。`dp[0]` 初始化为 `true`，其余为 `false`。
3.  外层循环遍历 `i` 从 1 到 `n`（代表子串的长度）。
4.  内层循环遍历 `j` 从 0 到 `i-1`（代表分割点）。
5.  在内层循环中，检查 `dp[j]` 是否为 `true` 以及子串 `s[j:i]` 是否在字典中。
6.  如果两个条件都满足，就将 `dp[i]` 设为 `true` 并跳出内层循环（因为已经找到了一个可行的拆分方案）。
7.  遍历结束后，返回 `dp[n]`。

**复杂度分析：**

*   **时间复杂度：** `O(n^2)`。两层循环，以及字符串切片操作。切片操作在 Python 中可能需要 `O(n)`，但通常可以认为是 `O(L)`，其中 `L` 是切片长度，这里 `L` 小于 `n`。
*   **空间复杂度：** `O(n)`。需要一个 `dp` 数组和哈希集合。哈希集合的空间取决于字典大小。

---

## Python 代码实现

```python
class Solution:
    def wordBreak(self, s: str, wordDict: list[str]) -> bool:
        n = len(s)
        word_set = set(wordDict)
        
        # dp[i] 表示 s 的前 i 个字符能否被拆分
        dp = [False] * (n + 1)
        dp[0] = True
        
        for i in range(1, n + 1):
            for j in range(i):
                # 如果 dp[j] 为 true，并且 s[j:i] 在字典中
                if dp[j] and s[j:i] in word_set:
                    dp[i] = True
                    break  # 找到了一个可行解，跳出内层循环
                    
        return dp[n]

```