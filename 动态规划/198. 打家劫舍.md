# 198. 打家劫舍

## 题目描述

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**提示：**

*   `1 <= nums.length <= 100`
*   `0 <= nums[i] <= 400`

---

## 解题引导

### 思路：动态规划

**思考过程：**

这个问题具有典型的最优子结构和重叠子问题，非常适合使用动态规划求解。

我们从左到右依次考虑每间房屋。对于第 `i` 间房屋，我们有两种选择：
1.  **偷窃第 `i` 间房屋**：如果我们选择偷这间房，根据规则，就不能偷它的邻居，即第 `i-1` 间房。所以，我们能获得的总金额是第 `i` 间房的金额 `nums[i]` 加上到第 `i-2` 间房为止能偷到的最高金额。
2.  **不偷窃第 `i` 间房屋**：如果我们不偷这间房，那么我们能获得的总金额就等于到第 `i-1` 间房为止能偷到的最高金额。

我们的目标是在这两种选择中取一个最大值。

**状态定义：**
`dp[i]`：表示偷窃前 `i` 间房屋所能获得到的最高金额。

**状态转移方程：**
根据上面的分析，对于第 `i` 间房屋（数组索引为 `i-1`），我们有：
`dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])`
*   `dp[i-1]` 对应不偷第 `i` 间房的情况。
*   `dp[i-2] + nums[i-1]` 对应偷第 `i` 间房的情况。

**边界条件：**
*   `dp[0] = 0`：没有房屋，偷到的金额为 0。
*   `dp[1] = nums[0]`：只有一间房，只能偷它。

**算法流程：**

1.  创建一个大小为 `n+1` 的 `dp` 数组，`n` 是房屋数量。
2.  初始化 `dp[0] = 0` 和 `dp[1] = nums[0]`。
3.  从 `i = 2` 遍历到 `n`，应用状态转移方程计算 `dp[i]`。
4.  最终返回 `dp[n]`。

**空间优化：**

`dp[i]` 的计算只依赖于前两个状态 `dp[i-1]` 和 `dp[i-2]`。因此，我们可以用两个变量来代替整个 `dp` 数组，将空间复杂度从 `O(n)` 降到 `O(1)`。

**复杂度分析（优化后）：**

*   **时间复杂度：** `O(n)`。一次遍历数组。
*   **空间复杂度：** `O(1)`。只使用常数个变量。

---

## Python 代码实现

```python
class Solution:
    def rob(self, nums: list[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        if n == 1:
            return nums[0]
        
        # 使用两个变量进行空间优化
        # prev2 代表 dp[i-2], prev1 代表 dp[i-1]
        prev2, prev1 = 0, 0
        
        for i in range(n):
            # current 代表 dp[i]
            current = max(prev1, prev2 + nums[i])
            prev2 = prev1
            prev1 = current
            
        return prev1

```