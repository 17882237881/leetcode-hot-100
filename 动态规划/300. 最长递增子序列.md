# 300. 最长递增子序列

## 题目描述

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

*   `1 <= nums.length <= 2500`
*   `-10^4 <= nums[i] <= 10^4`

---

## 解题引导

### 思路：动态规划

**思考过程：**

这个问题要求我们找到一个数组中最长的严格递增子序列。这是一个经典的动态规划问题。

我们需要定义一个 `dp` 数组来帮助我们解决问题。如何定义 `dp[i]` 的含义是关键。

一个常见的误区是定义 `dp[i]` 为“前 `i` 个元素的最长递增子序列长度”，但这样很难推导出状态转移方程。因为 `nums[i]` 是否被包含在子序列中，会影响后续的决策。

正确的定义应该是：

**状态定义：**
`dp[i]`：表示以 `nums[i]` 这个数**结尾**的最长递增子序列的长度。

**状态转移方程：**

为了计算 `dp[i]`，我们需要考虑 `nums[i]` 能接在哪个递增子序列的后面。我们遍历 `i` 之前的所有元素 `nums[j]`（其中 `0 <= j < i`）：

*   如果 `nums[i] > nums[j]`，这意味着 `nums[i]` 可以接在以 `nums[j]` 结尾的递增子序列后面，形成一个更长的递增子序列。这个新序列的长度是 `dp[j] + 1`。
*   我们需要在所有满足条件的 `j` 中，找到能使 `dp[j] + 1` 最大的那一个。

所以，状态转移方程是：
`dp[i] = max(dp[j]) + 1`，其中 `0 <= j < i` 且 `nums[j] < nums[i]`。

**边界条件（初始化）：**

对于任何一个元素 `nums[i]`，它自身至少可以形成一个长度为 1 的递增子序列。所以，我们将 `dp` 数组的所有元素初始化为 1。
`dp[i] = 1` for all `i`.

**最终结果：**

因为最长递增子序列可以以任何一个元素结尾，所以最终的结果不是 `dp[n-1]`，而是整个 `dp` 数组中的最大值。
`result = max(dp[0], dp[1], ..., dp[n-1])`

**算法流程：**

1.  创建一个和 `nums` 等长的 `dp` 数组，并全部初始化为 1。
2.  使用两层循环。外层循环遍历 `i` 从 0 到 `n-1`。
3.  内层循环遍历 `j` 从 0 到 `i-1`。
4.  在内层循环中，如果 `nums[i] > nums[j]`，则更新 `dp[i] = max(dp[i], dp[j] + 1)`。
5.  遍历完所有 `i` 后，返回 `dp` 数组中的最大值。

**复杂度分析：**

*   **时间复杂度：** `O(n^2)`。两层循环遍历数组。
*   **空间复杂度：** `O(n)`。需要一个 `dp` 数组来存储状态。

---

## Python 代码实现

```python
class Solution:
    def lengthOfLIS(self, nums: list[int]) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        dp = [1] * n
        
        for i in range(n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
                    
        return max(dp)

```