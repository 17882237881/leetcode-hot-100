# 1. 两数之和

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值 `target` 的那两个整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**示例 2：**

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

**示例 3：**

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

*   `2 <= nums.length <= 10^4`
*   `-10^9 <= nums[i] <= 10^9`
*   `-10^9 <= target <= 10^9`
*   **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n^2)` 的算法吗？

---

## 解题引导

### 思路一：暴力解法

**思考过程：**

最容易想到的方法是什么？题目要求我们找到两个数，它们的和是 `target`。那我们就干脆遍历数组，对于每一个数，再遍历它后面的所有数，看看两者的和是不是 `target`。

1.  用第一层循环，从第一个元素开始，依次选中数组中的每个元素 `nums[i]`。
2.  用第二层循环，从 `i + 1` 开始，依次选中 `nums[i]` 后面的每个元素 `nums[j]`。
3.  在第二层循环中，判断 `nums[i] + nums[j]` 是否等于 `target`。
4.  如果等于，那么 `i` 和 `j` 就是我们要找的下标，直接返回 `[i, j]`。

**复杂度分析：**

*   **时间复杂度：** `O(n^2)`。因为我们用了两层嵌套循环，外层循环 `n` 次，内层循环平均 `n/2` 次。
*   **空间复杂度：** `O(1)`。我们只使用了常数级别的额外空间。

这种方法虽然简单，但是效率不高。题目的“进阶”提示我们，有更好的方法。

### 思路二：哈希表优化

**思考过程：**

暴力解法的瓶颈在哪里？在于“寻找 `target - nums[i]`”这一步，我们是通过又一次遍历来实现的。有没有更快的方法来寻找一个数是否存在于数组中呢？

答案是 **哈希表** (在 Python 中是字典 `dict`)。哈希表提供了近乎 `O(1)` 时间复杂度的查找、插入和删除操作。

我们可以这样做：

1.  创建一个空的哈希表 `hash_map`，用来存放我们已经遍历过的数字和它们的下标。格式为 `{数字: 下标}`。
2.  遍历数组 `nums` 中的每一个数 `num`（同时获取它的下标 `i`）。
3.  对于每个 `num`，我们计算需要配对的另一个数 `complement = target - num`。
4.  然后，我们在哈希表 `hash_map` 中查找 `complement` 是否存在。
    *   **如果存在**，说明我们找到了配对的两个数！`complement` 的下标已经存在哈希表里了，当前数 `num` 的下标是 `i`。我们直接返回 `[hash_map[complement], i]`。
    *   **如果不存在**，说明到目前为止，还没有数字能和当前的 `num` 配对。我们把当前的 `num` 和它的下标 `i` 存入哈希表 `hash_map` 中，即 `hash_map[num] = i`，以便后续的数字来和它配对。

**为什么这样可行？**

当我们遍历到 `nums[i]` 时，我们去哈希表里寻找 `target - nums[i]`。如果找到了，说明 `target - nums[i]` 这个数在 `nums[i]` **之前**出现过。这样我们就凑成了一对，并且由于我们是从前往后遍历的，所以两个数的下标肯定不同。

**复杂度分析：**

*   **时间复杂度：** `O(n)`。我们只需要遍历一次数组。哈希表的查找和插入操作平均时间复杂度都是 `O(1)`。
*   **空间复杂度：** `O(n)`。在最坏的情况下，我们需要把数组中所有的数都存入哈希表。

---

## Python 代码实现

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        """
        使用哈希表来优化查找过程
        """
        hash_map = {}  # 创建一个哈希表（字典）来存储数字及其索引
        
        # 遍历数组，enumerate可以同时获得索引和值
        for i, num in enumerate(nums):
            # 计算我们需要寻找的另一个数
            complement = target - num
            
            # 检查 complement 是否已经在哈希表中
            if complement in hash_map:
                # 如果在，说明找到了答案，返回两个数的索引
                return [hash_map[complement], i]
            
            # 如果 complement 不在哈希表中，将当前的数和它的索引存入哈希表
            # 注意：我们是在检查之后再存入，这样可以避免同一个元素被使用两次
            # 例如 nums = [3, 2, 4], target = 6
            # 遍历到 3 时，寻找 3，没找到，存入 {3: 0}
            # 遍历到 2 时，寻找 4，没找到，存入 {3: 0, 2: 1}
            # 遍历到 4 时，寻找 2，找到了！hash_map[2] 是 1，当前索引是 2，返回 [1, 2]
            hash_map[num] = i
            
        # 题目保证有解，所以这里实际上不会执行到
        return []

```
