# 15. 三数之和

## 题目描述
给你一个整数数组 `nums`，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k`，同时还满足 `nums[i] + nums[j] + nums[k] == 0`。

请你返回所有和为 0 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。

## 示例
```
示例 1:
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]

示例 2:
输入：nums = [0,1,1]
输出：[]

示例 3:
输入：nums = [0,0,0]
输出：[[0,0,0]]
```

## 约束条件
- 3 <= nums.length <= 3000
- -10^5 <= nums[i] <= 10^5

## 思考过程

### 🤔 第一步：理解问题与暴力解法
- 我们要找到所有独特的三个数，它们的和为 0。
- 最直接的想法是使用三层循环，遍历所有可能的三数组合。

**思考题：**
- 三层循环的时间复杂度是多少？
- 如何处理找到的三元组的重复问题？例如 `[-1, 0, 1]` 和 `[0, -1, 1]` 是同一个组合。

<details>
<summary>点击查看分析</summary>

- 三层循环的时间复杂度是 O(n³)，对于 n=3000 来说太慢了。
- 为了去重，我们可以将找到的每个三元组排序，然后存入一个哈希集合（Set）中。但这依然无法解决时间复杂度过高的问题。

</details>

### 🤔 第二步：降维思考
O(n³) 太慢，我们需要优化。能不能把问题简化一下？

如果我们能把问题从“找三个数”降维到“找两个数”，情况就会好很多。

**核心思路：** 先固定一个数，然后问题就变成了在剩下的数中寻找“两数之和”等于某个目标值。

`a + b + c = 0`  =>  `b + c = -a`

这样，我们可以用一层循环来固定 `a`，然后用一个更高效的方法在剩余部分找到 `b` 和 `c`。

### 🤔 第三步：排序 + 双指针
“两数之和”问题有一个经典的解法：如果数组是有序的，就可以使用**双指针**。

这给了我们一个清晰的优化路径：

1.  **排序**：首先对整个数组 `nums` 进行排序。这不仅能让双指针生效，还极大地简化了后续的**去重**操作。
2.  **主循环**：遍历排序后的数组，用 `i` 来固定第一个数 `nums[i]`。
3.  **双指针查找**：在 `i` 后面的部分 `[i+1, n-1]`，设置 `left = i + 1` 和 `right = n - 1`。我们的目标是在这个范围内找到 `nums[left] + nums[right] == -nums[i]`。

**思考题：**
- 在双指针移动过程中，如果 `nums[left] + nums[right]` 太小了怎么办？如果太大了又怎么办？
- 排序后，如何高效地跳过重复的三元组？

<details>
<summary>点击查看分析</summary>

- 如果 `sum < target`，说明和太小，我们需要一个更大的数，所以 `left++`。
- 如果 `sum > target`，说明和太大，我们需要一个更小的数，所以 `right--`。
- **去重是关键**：
    - **对固定的数 `nums[i]` 去重**：如果 `nums[i]` 和前一个数 `nums[i-1]` 相同，那么以 `nums[i]` 为基础的查找会和以 `nums[i-1]` 为基础的查找产生重复结果，所以可以直接跳过。
    - **对结果中的 `nums[left]` 和 `nums[right]` 去重**：当我们找到一个满足条件的 `[nums[i], nums[left], nums[right]]` 后，我们需要移动 `left` 和 `right` 指针。此时，要跳过所有与当前 `nums[left]` 和 `nums[right]` 重复的元素，以避免 `[-1, 0, 1]` 和 `[-1, 0, 1]` 这样的重复（如果数组中有多个0和1）。

</details>

### 🤔 第四步：算法步骤总结
1. 对数组 `nums` 进行升序排序。
2. 遍历数组，对于每个元素 `nums[i]`：
   a. **剪枝优化**：如果 `nums[i] > 0`，因为数组已经排序，后面的数都比它大，三数之和不可能为 0，可以直接结束循环。
   b. **去重**：如果 `i > 0` 且 `nums[i] == nums[i-1]`，则跳过，避免重复计算。
   c. 初始化双指针 `left = i + 1`, `right = len(nums) - 1`。
   d. 在 `left < right` 的条件下循环：
      i.   计算三数之和 `s = nums[i] + nums[left] + nums[right]`。
      ii.  如果 `s < 0`，则 `left++`。
      iii. 如果 `s > 0`，则 `right--`。
      iv.  如果 `s == 0`，则找到了一个解：
           - 将 `[nums[i], nums[left], nums[right]]` 添加到结果列表。
           - **对 `left` 和 `right` 去重**：移动 `left` 和 `right` 指针，跳过所有重复的元素。
           - 最后，将 `left` 和 `right` 再各移动一位，开始寻找下一个可能的解。
3. 返回结果列表。

**时间复杂度：** O(n²) - 排序占 O(n log n)，两层循环占 O(n²)。
**空间复杂度：** O(1) 或 O(log n) - 取决于排序算法使用的栈空间。

## 代码实现

### Python
```python
def threeSum(nums: list[int]) -> list[list[int]]:
    """
    使用“排序 + 双指针”解决三数之和问题
    """
    nums.sort()  # 排序是关键
    result = []
    n = len(nums)
    
    # 外层循环，固定第一个数
    for i in range(n - 2):
        # 剪枝：如果最小的数都大于0，直接结束
        if nums[i] > 0:
            break
        
        # 去重：跳过重复的第一个数
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        # 双指针在 i 后面的部分寻找另外两个数
        left, right = i + 1, n - 1
        target = -nums[i]  # 目标和
        
        while left < right:
            current_sum = nums[left] + nums[right]
            
            if current_sum == target:
                # 找到一组解
                result.append([nums[i], nums[left], nums[right]])
                
                # 去重：跳过所有重复的第二个数
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # 去重：跳过所有重复的第三个数
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                # 移动指针，寻找新的可能性
                left += 1
                right -= 1
            elif current_sum < target:
                left += 1  # 和太小，左指针右移
            else:
                right -= 1  # 和太大，右指针左移
    
    return result

```

## 关键点总结
1. **排序**：是使用双指针和高效去重的前提。
2. **降维**：将三数之和问题转化为“固定一数 + 两数之和”问题。
3. **双指针**：在有序数组中高效查找两数之和。
4. **去重**：是本题的难点和重点，需要在三个位置（固定的数、左指针、右指针）都进行考虑。
