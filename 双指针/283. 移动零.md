# 283. 移动零

## 题目描述
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

## 示例
```
示例 1:
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

示例 2:
输入: nums = [0]
输出: [0]
```

## 约束条件
- 1 <= nums.length <= 10^4
- -2^31 <= nums[i] <= 2^31 - 1

## 思考过程

### 🤔 第一步：理解问题
让我们先分析一下这个问题：
- 需要将所有的 0 移动到数组末尾
- 保持非零元素的相对顺序不变
- 必须原地操作，不能使用额外的数组

**思考题：** 如果允许使用额外空间，你会怎么做？

<details>
<summary>点击查看提示</summary>

可以创建一个新数组，先遍历一遍原数组，把所有非零元素按顺序放进新数组，然后计算新数组和原数组的长度差，在新数组末尾补上相应数量的零。但题目要求原地操作。

</details>

### 🤔 第二步：寻找模式
让我们手动模拟一下 `[0,1,0,3,12]` 的处理过程：

```
初始: [0, 1, 0, 3, 12]
目标: [1, 3, 12, 0, 0]
```

**思考题：** 你能发现什么规律吗？非零元素是如何移动的？

<details>
<summary>点击查看分析</summary>

观察发现：
- 非零元素 1, 3, 12 保持了原来的相对顺序。
- 它们好像被“压缩”到了数组的前面。
- 后面空出来的位置用 0 填充。

这提示我们可以用一个指针来记录“当前非零元素应该被放置的位置”。

</details>

### 🤔 第三步：双指针策略
现在让我们思考双指针的具体实现。一个指针 `right` 用来遍历整个数组，另一个指针 `left` 用来指向“下一个非零元素应该被放置的位置”。

**算法思路：**
1. 初始化 `left = 0`。
2. 用 `right` 指针从头到尾遍历数组。
3. 如果 `nums[right]` 是一个**非零**元素，我们就把它放到 `nums[left]` 的位置，然后将 `left` 指针向后移动一位 (`left++`)。
4. 遍历结束后，所有非零元素都已经被按顺序移动到了数组的前 `left` 个位置。
5. 最后，将数组从 `left` 位置到末尾的所有元素都设置为 0。

### 🤔 第四步：手动模拟
让我们用这个思路手动模拟 `[0,1,0,3,12]`：

```
初始状态: [0, 1, 0, 3, 12], left = 0

right = 0, nums[0] is 0.  什么都不做。
           [0, 1, 0, 3, 12], left = 0

right = 1, nums[1] is 1 (非零). 将它放到 nums[left] (即 nums[0]) 的位置. left++.
           [1, 1, 0, 3, 12], left = 1

right = 2, nums[2] is 0.  什么都不做。
           [1, 1, 0, 3, 12], left = 1

right = 3, nums[3] is 3 (非零). 将它放到 nums[left] (即 nums[1]) 的位置. left++.
           [1, 3, 0, 3, 12], left = 2

right = 4, nums[4] is 12 (非零). 将它放到 nums[left] (即 nums[2]) 的位置. left++.
           [1, 3, 12, 3, 12], left = 3

遍历结束。现在 left = 3。将从索引 3 开始的位置填充为 0。
nums[3] = 0
nums[4] = 0

最终结果: [1, 3, 12, 0, 0]
```

这个方法被称为**快慢指针**，`right` 是快指针，`left` 是慢指针。

## 代码实现

### Python
```python
def moveZeroes(nums: list[int]) -> None:
    """
    使用快慢指针原地移动零，同时保持非零元素相对顺序。
    Do not return anything, modify nums in-place instead.
    """
    left = 0  # 慢指针，指向下一个非零元素应该放置的位置
    
    # 第一次遍历：将所有非零元素移到前面
    for right in range(len(nums)): # 快指针，遍历整个数组
        if nums[right] != 0:
            # 如果快慢指针不指向同一个位置，才进行赋值，避免不必要的操作
            if left != right:
                nums[left] = nums[right]
            left += 1
    
    # 第二次遍历：将慢指针之后的所有位置填充为0
    while left < len(nums):
        nums[left] = 0
        left += 1

```

## 复杂度分析
- **时间复杂度：** O(n) - 因为我们只对数组进行了常数次遍历。
- **空间复杂度：** O(1) - 我们是在原地操作，只使用了常数个额外变量。

## 关键点总结
1. **快慢指针**：这是一种特殊的双指针，一个指针用于遍历，另一个指针用于记录有效位置，常用于解决原地修改数组的问题。
2. **原地操作**：通过覆盖的方式实现，避免了创建新数组带来的额外空间开销。
3. **保持相对顺序**：由于慢指针 `left` 和快指针 `right` 都是从左到右单向移动，非零元素被处理的顺序与它们在原数组中的顺序一致，因此相对顺序得以保持。
