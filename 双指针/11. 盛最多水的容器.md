# 11. 盛最多水的容器

## 题目描述
给定一个长度为 n 的整数数组 `height`。有 n 条垂线，第 i 条线的两个端点是 `(i, 0)` 和 `(i, height[i])`。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：** 你不能倾斜容器。

## 示例
```
示例 1:
输入：height = [1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

示例 2:
输入：height = [1,1]
输出：1
```

## 约束条件
- n == height.length
- 2 <= n <= 10^5
- 0 <= height[i] <= 10^4

## 思考过程

### 🤔 第一步：理解问题
- 我们要找两条垂直线，围成一个容器，使其容纳的水最多。
- 容器的容量由什么决定？**宽度** 和 **高度**。
- **宽度** 是两条线在 x 轴上的距离。
- **高度** 是两条线中较短那条的高度，因为水会从短板处溢出。
- **面积 = 宽度 × 高度**

### 🤔 第二步：暴力解法
最直接的想法是，尝试所有可能的线对组合，计算它们的面积，然后找到最大的那个。

**思考题：** 
- 如果用两层循环来实现，时间复杂度是多少？
- 对于 `n <= 10^5` 的约束，这个时间复杂度能接受吗？

<details>
<summary>点击查看分析</summary>

- 两层循环需要 O(n²) 的时间复杂度。
- 当 n = 10^5 时，n² = 10^10，计算量太大了，肯定会超时。所以我们需要更优化的方法。

</details>

### 🤔 第三步：寻找优化思路
暴力解法的问题在于，它做了很多不必要的计算。我们能不能用一种更聪明的方式来移动指针，而不是盲目地遍历所有组合？

想象一下，我们把两个指针分别放在数组的**最左端**和**最右端**。这样，我们就得到了一个初始容器。

- 这个容器的**宽度是最大的**。
- 接下来，我们应该移动哪个指针呢？左指针还是右指针？

**思考题：**
- 假设 `height[left] < height[right]`，即左边的板子更短。
- 如果我们移动右指针（`right--`），会发生什么？
- 如果我们移动左指针（`left++`），又会发生什么？

<details>
<summary>点击查看分析</summary>

- **移动右指针（长板）**：新的宽度变小了，而容器的高度取决于短板（左板），高度**最多不变或者变小**。所以，面积**绝对不会变大**。
- **移动左指针（短板）**：新的宽度变小了，但是新的左板 `height[left+1]` **可能比原来的左板更高**，这样就有可能得到一个更高的容器高度，从而得到更大的面积。

**结论：** 我们应该总是移动**指向较短板的那个指针**。这是这个算法的核心贪心思想。

</details>

### 🤔 第四步：双指针算法
基于上面的分析，我们可以得出双指针算法的流程：

1. 初始化 `left = 0`, `right = n - 1`，`max_area = 0`。
2. 当 `left < right` 时，循环执行：
   a. 计算当前容器的宽度 `width = right - left`。
   b. 计算当前容器的高度 `h = min(height[left], height[right])`。
   c. 更新最大面积 `max_area = max(max_area, width * h)`。
   d. 比较 `height[left]` 和 `height[right]`，移动指向较短板的指针。
3. 循环结束后，`max_area` 就是最终答案。

**时间复杂度：** O(n) - 因为 `left` 和 `right` 指针总共只会移动 n 次。
**空间复杂度：** O(1) - 只使用了常数个额外变量。

## 代码实现

### Python
```python
def maxArea(height: list[int]) -> int:
    """
    使用双指针计算最大容器面积
    """
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        # 计算当前容器的宽度
        width = right - left
        
        # 计算当前容器的高度（由较短的板决定）
        current_height = min(height[left], height[right])
        
        # 计算当前面积并更新最大面积
        current_area = width * current_height
        max_area = max(max_area, current_area)
        
        # 移动指向较短板的指针
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
            
    return max_area

```

## 关键点总结
1. **双指针**：从两端开始，向中间收敛，这是一种常见的优化技巧。
2. **贪心策略**：每次都移动较短的板，因为移动较长的板不可能使面积增大。这是解题的关键。
3. **面积计算**：容器的面积由 **宽度** 和 **短板高度** 共同决定。
