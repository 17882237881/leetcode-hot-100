# 239. 滑动窗口最大值

## 题目描述
给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。每次滑动窗口向右移动一位。

返回 *滑动窗口中的最大值* 组成的数组。

## 示例
```
示例 1:
输入: nums = [1,3,-1,-3,5,3,6,7], k = 3
输出: [3,3,5,5,6,7]
解释: 
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

示例 2:
输入: nums = [1], k = 1
输出: [1]
```

## 约束条件
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- 1 <= k <= nums.length

## 思考过程

### 🤔 第一步：理解问题
- 我们有一个固定大小为 `k` 的窗口在数组 `nums` 上滑动。
- 每次窗口向右移动一格。
- 我们需要记录**每个窗口状态下**的最大值。
- 最终返回一个包含所有这些最大值的列表。

### 🤔 第二步：暴力解法
最直接的想法是，模拟窗口的滑动过程。

1. 遍历 `s` 中所有可能的窗口起点（从 `0` 到 `n-k`）。
2. 对于每个窗口，遍历其中的 `k` 个元素，找到最大值。
3. 将找到的最大值存入结果列表。

**思考题：** 这个方法的时间复杂度是多少？对于 `n <= 10^5` 是否可行？

<details>
<summary>点击查看分析</summary>

- 有 `n-k+1` 个窗口，每个窗口找最大值需要 O(k) 的时间。
- 总时间复杂度是 O(n*k)。
- 在最坏情况下，`k` 可能接近 `n/2`，复杂度接近 O(n²)，对于 `n = 10^5` 来说会超时。

</details>

### 🤔 第三步：寻找优化思路
暴力解法的瓶颈在于，每次窗口滑动时，我们都重新计算了最大值。而相邻的窗口大部分元素是重合的，这里面有大量的信息被浪费了。

我们需要一个数据结构，能够：
1. 随着窗口滑动，高效地加入新元素（窗口右侧）。
2. 随着窗口滑动，高效地删除旧元素（窗口左侧）。
3. 在 O(1) 时间内返回当前窗口的最大值。

**思考题：**
- 普通的队列能做到吗？（入队出队O(1)，但找最大值O(k)）
- 大顶堆（Priority Queue）能做到吗？（找最大值O(1)，入队O(logk)，但删除指定元素O(k)）

看来我们需要一个更特殊的数据结构。

### 🤔 第四步：单调队列（Deque）
让我们设计一个特殊的队列，这个队列具有一个性质：**队列内的元素从队头到队尾是单调递减的**。

这个队列我们用双端队列（Deque）来实现，里面存储的是元素的**索引**，而不是元素本身。存储索引的好处是，我们既可以通过索引知道元素的值，也可以通过索引判断元素是否已经滑出窗口。

**这个单调队列如何工作？**

1.  **入队规则（从队尾入）**：
    当一个新元素 `nums[i]` 要进入队列时，我们从**队尾**开始，将所有比 `nums[i]` **小**的元素的索引都**弹出**。然后再将 `i` 的索引加入队尾。
    **为什么这么做？** 因为如果 `nums[j] < nums[i]` 且 `j < i`，那么只要 `nums[i]` 还在窗口内，`nums[j]` 就永远不可能成为最大值了，所以可以放心地把它从队列中扔掉。

2.  **出队规则（从队头出）**：
    队列的队头，始终保存着**当前窗口内最大值的索引**。
    每次窗口滑动时，我们需要检查队头的索引是否已经**过期**（即 `deque[0] <= i - k`）。如果过期了，就从队头弹出。

**算法流程：**
1. 初始化一个双端队列 `deque` 和一个结果列表 `result`。
2. 遍历 `nums` 数组，索引从 `i = 0` 到 `n-1`：
   a. **维护单调性**：当队列不为空，且队尾索引对应的元素小于等于 `nums[i]` 时，从队尾弹出。
   b. **入队**：将当前索引 `i` 加入队尾。
   c. **检查队头是否过期**：如果队头索引小于 `i - k + 1`，说明队头元素已经滑出窗口，从队头弹出。
   d. **记录结果**：当窗口形成后（即 `i >= k - 1`），队头元素就是当前窗口的最大值。将 `nums[deque[0]]` 加入 `result` 列表。

**时间复杂度：** O(n) - 每个元素的索引最多入队一次，出队一次。
**空间复杂度：** O(k) - 双端队列中最多存储 k 个元素的索引。

## 代码实现

### Python
```python
import collections

def maxSlidingWindow(nums: list[int], k: int) -> list[int]:
    """
    使用单调队列（双端队列）解决滑动窗口最大值问题。
    """
    if not nums or k == 0:
        return []
    
    # deque 存储的是元素的索引，并且索引对应的元素值是单调递减的
    deque = collections.deque()
    result = []
    
    for i, num in enumerate(nums):
        # 1. 移除过期的队头元素
        # i - k 是窗口前一个位置的索引，如果队头索引小于等于它，说明已滑出窗口
        if deque and deque[0] <= i - k:
            deque.popleft()
            
        # 2. 维护队列的单调递减性
        # 从队尾移除所有小于当前元素的索引
        while deque and nums[deque[-1]] < num:
            deque.pop()
        
        # 3. 将当前元素索引加入队列
        deque.append(i)
        
        # 4. 当窗口完全形成后，记录最大值
        # 窗口形成是从索引 k-1 开始的
        if i >= k - 1:
            # 此时的队头，就是当前窗口最大值的索引
            result.append(nums[deque[0]])
            
    return result

```

## 关键点总结
1. **单调队列**：是解决滑动窗口最值问题的“神器”。其核心思想是，在队列中只保留那些“有潜力”成为未来最大值的元素，从而避免了重复的比较。
2. **存储索引**：在队列中存储索引而不是元素本身，是一个非常关键的技巧。索引既能告诉我们元素的值，也能告诉我们元素的位置，方便判断其是否过期。
3. **均摊复杂度**：虽然 `while` 循环看起来可能会增加复杂度，但每个元素最多只入队和出队一次，所以总的时间复杂度是均摊 O(n) 的。
