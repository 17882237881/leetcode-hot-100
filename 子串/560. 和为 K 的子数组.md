# 560. 和为 K 的子数组

## 题目描述
给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回该数组中和为 `k` 的 **子数组** 的个数。

**子数组** 是数组中元素的连续非空序列。

## 示例
```
示例 1:
输入: nums = [1,1,1], k = 2
输出: 2
解释: 和为 2 的子数组是 [1,1] 和 [1,1]。

示例 2:
输入: nums = [1,2,3], k = 3
输出: 2
解释: 和为 3 的子数组是 [1,2] 和 [3]。
```

## 约束条件
- 1 <= nums.length <= 2 * 10^4
- -1000 <= nums[i] <= 1000
- -10^7 <= k <= 10^7

## 思考过程

### 🤔 第一步：理解问题
- 我们要找的是 **连续** 的子数组。
- 这些子数组的元素之和需要恰好等于 `k`。
- 我们需要返回的是满足条件的子数组的 **个数**。
- **重要提示**：`nums` 数组中包含**负数**！这一点非常关键。

### 🤔 第二步：暴力解法
最直接的想法是，找出所有可能的子数组，计算它们的和，然后看是否等于 `k`。

**思考题：**
- 如何用循环实现找到所有子数组？
- 这个方法的时间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 可以用两层循环。外层循环 `i` 固定子数组的起点，内层循环 `j` 固定子数组的终点。
- 对于每个子数组 `nums[i:j+1]`，再求和。
- 总时间复杂度是 O(n³)。通过在内层循环中累加和，可以优化到 O(n²)。
- 对于 `n <= 2 * 10^4`，O(n²) 依然太慢，会超时。

</details>

### 🤔 第三步：为什么滑动窗口不行？
一看到“连续子数组”，我们可能会想到滑动窗口。但是，标准的滑动窗口方法在这里行不通。

**思考题：** 为什么滑动窗口在这里会失效？

<details>
<summary>点击查看分析</summary>

- 标准的滑动窗口依赖于一个**单调性**。例如，在求“最长无重复子串”时，扩大窗口，重复的概率会增加或不变；在求“最小覆盖子串”时，扩大窗口，覆盖的可能性会增加或不变。
- 在本题中，由于**负数的存在**，窗口的和不具有单调性。扩大窗口（`right++`），和可能增加，也可能减少。收缩窗口（`left++`）也是如此。
- 我们无法根据当前窗口的和 `current_sum` 与 `k` 的大小关系，来决定是该扩大还是收缩窗口。例如，`current_sum > k`，我们不能断定就该收缩左边界，因为下一个元素可能是负数，反而能让和更接近 `k`。

</detaisl>

### 🤔 第四步：前缀和 + 哈希表
既然滑动窗口不行，我们需要换个思路。O(n²) 的瓶颈在于，对于每个起点 `i`，我们都重新计算了到终点 `j` 的和。

**核心思路：**
- 子数组 `nums[i:j+1]` 的和，可以用**前缀和**来快速计算。
- 设 `prefix_sum[x]` 为 `nums[0...x]` 的和。
- 那么，子数组 `nums[i...j]` 的和就等于 `prefix_sum[j] - prefix_sum[i-1]`。

我们的目标是找到满足下面条件的 `(i, j)` 对的数量：
`prefix_sum[j] - prefix_sum[i-1] == k`

把这个公式变形一下：
`prefix_sum[i-1] == prefix_sum[j] - k`

这个公式给了我们一个绝妙的思路：
- 当我们遍历到 `j` 时，我们计算出了当前的 `prefix_sum[j]`。
- 此时，我们**不再需要回头去找 `i`**。
- 我们只需要问一个问题：“**在 `j` 之前，有多少个 `i-1`，使得 `prefix_sum[i-1]` 恰好等于 `prefix_sum[j] - k`？**”

这个问题可以用一个哈希表来完美解决！

### 🤔 第五步：算法步骤总结
1. 初始化一个哈希表 `prefix_sum_map`，用来存储**某个前缀和出现的次数**。`key` 是前缀和的值，`value` 是该值出现的次数。
2. 为了处理从索引 0 开始的子数组（即 `i=0` 的情况），我们需要一个 `prefix_sum[-1]`，它的值为 0。所以，我们在哈希表中预先放入 `{0: 1}`。
3. 初始化 `current_sum = 0`，`count = 0`。
4. 遍历数组 `nums` 中的每个数字 `num`：
   a. 更新当前的前缀和：`current_sum += num`。
   b. **查找目标**：在哈希表中查找 `target = current_sum - k`。如果找到了，说明存在若干个以当前位置为终点的子数组，其和为 `k`。我们将这些子数组的数量加入 `count`：`count += prefix_sum_map.get(target, 0)`。
   c. **更新哈希表**：将当前的前缀和 `current_sum` 存入哈希表（或更新其出现次数）：`prefix_sum_map[current_sum] = prefix_sum_map.get(current_sum, 0) + 1`。
5. 遍历结束后，返回 `count`。

**时间复杂度：** O(n) - 我们只遍历一次数组。
**空间复杂度：** O(n) - 在最坏情况下，所有前缀和都不同，哈希表需要存储 n 个键值对。

## 代码实现

### Python
```python
def subarraySum(nums: list[int], k: int) -> int:
    """
    使用前缀和 + 哈希表统计和为 k 的子数组个数。
    """
    # prefix_sum_map: {前缀和: 出现次数}
    prefix_sum_map = {0: 1}  # 初始化，处理从索引0开始的子数组
    count = 0
    current_sum = 0
    
    for num in nums:
        # 1. 计算当前的前缀和
        current_sum += num
        
        # 2. 寻找目标前缀和
        # 我们需要找的前缀和是 current_sum - k
        target = current_sum - k
        if target in prefix_sum_map:
            count += prefix_sum_map[target]
        
        # 3. 将当前前缀和存入哈希表
        prefix_sum_map[current_sum] = prefix_sum_map.get(current_sum, 0) + 1
            
    return count

```

## 关键点总结
1. **前缀和**：是解决子数组和相关问题的利器，能将求任意子数组和的时间复杂度从 O(n) 降到 O(1)。
2. **哈希表优化**：通过 `prefix_sum[i-1] == prefix_sum[j] - k` 的转换，将两层循环的查找问题变成了 O(1) 的哈希表查找，是本题从 O(n²) 优化到 O(n) 的关键。
3. **负数的重要性**：题目中的负数使得问题不能用常规的滑动窗口解决，从而引导我们走向前缀和的思路。
4. **初始化 `{0: 1}`**：这个细节非常重要，它相当于一个虚拟的 `prefix_sum[-1] = 0`，用于正确统计那些从数组开头 `nums[0]` 就开始且和为 `k` 的子数组。
