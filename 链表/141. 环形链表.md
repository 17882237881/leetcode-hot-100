# 141. 环形链表

## 题目描述
给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表中节点的索引（从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识环的实际位置。

如果链表中存在环 ，则返回 `true` 。 否则，返回 `false` 。

## 示例
```
示例 1:
输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环，其尾部连接到第二个节点。

示例 2:
输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环，其尾部连接到第一个节点。

示例 3:
输入: head = [1], pos = -1
输出: false
解释: 链表中没有环。
```

## 约束条件
- 链表中节点的数目范围是 `[0, 10^4]`
- `-10^5 <= Node.val <= 10^5`
- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。

## 思考过程

### 🤔 第一步：理解问题
- 我们需要判断一个单链表是否包含环。
- 环意味着链表的某个节点的 `next` 指针指向了链表前面的某个节点，形成一个闭环。
- `pos` 只是为了说明问题，我们不能直接使用它。

### 🤔 第二步：朴素解法（哈希表）
最直观的想法是，遍历链表，并将访问过的节点存储到一个哈希集合中。如果再次访问到哈希集合中已有的节点，就说明存在环。

**思考题：**
- 这个方法的时间和空间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 时间复杂度：O(n) - 遍历链表一次。
- 空间复杂度：O(n) - 最坏情况下，所有节点都存储在哈希集合中。
- 满足时间要求，但不满足进阶要求（O(1) 空间）。

</detaisl>

### 🤔 第三步：O(1) 空间的关键 -> 快慢指针（Floyd 判圈算法）
为了实现 O(1) 空间，我们不能使用额外的存储。我们需要一种巧妙的方法来检测环。

**核心思路：**
- 使用两个指针，一个快指针 `fast`，一个慢指针 `slow`。
- `fast` 每次移动两步，`slow` 每次移动一步。
- 如果链表中存在环，那么 `fast` 指针最终一定会追上 `slow` 指针。
- 如果链表中没有环，`fast` 指针会先到达链表末尾（`None`）。

**思考题：**
- 为什么快指针一定会追上慢指针？

<details>
<summary>点击查看分析</summary>

- 想象一下在一个圆形跑道上，两个人以不同的速度跑步。只要速度不同，跑得快的人总会追上跑得慢的人。
- 在链表中，当 `fast` 和 `slow` 都进入环后，它们之间的距离会逐渐缩小。每次 `fast` 比 `slow` 多走一步，它们之间的距离就减少 1。最终，距离会变为 0，即它们相遇。

</detaisl>

### 🤔 第四步：算法步骤总结
1. 处理特殊情况：如果链表为空或只有一个节点，不可能有环，返回 `False`。
2. 初始化快慢指针：`slow = head`, `fast = head.next`。
3. 当 `fast` 和 `fast.next` 都不为 `None` 时，循环执行：
   a. 如果 `slow == fast`，说明相遇，存在环，返回 `True`。
   b. `slow` 移动一步：`slow = slow.next`。
   c. `fast` 移动两步：`fast = fast.next.next`。
4. 如果循环结束，`fast` 或 `fast.next` 为 `None`，说明 `fast` 已经到达链表末尾，没有环，返回 `False`。

**时间复杂度：** O(n) - 快慢指针最多遍历链表两次。
**空间复杂度：** O(1) - 只使用了常数个额外变量。

## 代码实现

### Python
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def hasCycle(head: ListNode) -> bool:
    """
    使用快慢指针（Floyd 判圈算法）判断链表是否有环。
    """
    if not head or not head.next:
        return False
    
    slow = head
    fast = head.next # fast 比 slow 先走一步，避免一开始就相等
    
    while fast and fast.next:
        if slow == fast:
            return True # 快慢指针相遇，存在环
        
        slow = slow.next
        fast = fast.next.next
        
    return False # fast 到达链表末尾，没有环

```

## 关键点总结
1. **快慢指针**：`fast` 每次走两步，`slow` 每次走一步。这是检测环的核心思想。
2. **相遇即有环**：如果 `fast` 和 `slow` 相遇，则链表中存在环。
3. **`fast` 到达末尾即无环**：如果 `fast` 或 `fast.next` 变为 `None`，说明链表没有环。
4. **O(1) 空间**：通过巧妙的指针移动，实现了常数级别的空间复杂度。
