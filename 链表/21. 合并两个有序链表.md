# 21. 合并两个有序链表

## 题目描述
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

## 示例
```
示例 1:
输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]

示例 2:
输入: l1 = [], l2 = []
输出: []

示例 3:
输入: l1 = [], l2 = [0]
输出: [0]
```

## 约束条件
- 两个链表的节点数目范围是 `[0, 50]`
- `-100 <= Node.val <= 100`
- `l1` 和 `l2` 均按 **非递减顺序** 排列

## 思考过程

### 🤔 第一步：理解问题
- 我们有两个已经排好序的链表。
- 需要将它们合并成一个新的、同样排好序的链表。
- 新链表包含所有节点。

### 🤔 第二步：如何合并两个有序数组？
这个问题和合并两个有序数组非常相似。我们可以使用双指针的方法。

**思考题：**
- 如果是数组，你会怎么做？

<details>
<summary>点击查看分析</summary>

- 创建一个新数组。
- 用两个指针分别指向两个数组的开头。
- 比较两个指针指向的元素，将较小的那个放入新数组，并移动对应的指针。
- 重复直到一个数组遍历完，然后将另一个数组剩余的元素全部放入新数组。

</detaisl>

### 🤔 第三步：链表的合并
链表的合并思路与数组类似，但操作的是节点和指针。

**核心思路：**
- 创建一个**哑节点（dummy node）**作为新链表的头，这样可以简化代码，避免对头节点的特殊处理。
- 使用一个 `current` 指针来构建新链表，它总是指向新链表的最后一个节点。
- 使用两个指针 `p1` 和 `p2` 分别遍历 `l1` 和 `l2`。

### 🤔 第四步：算法步骤总结
1. 创建一个哑节点 `dummy_head = ListNode(0)`。
2. 创建一个 `current` 指针，指向 `dummy_head`。
3. 使用 `p1 = l1`, `p2 = l2` 分别遍历两个链表。
4. 当 `p1` 和 `p2` 都不为 `None` 时，循环执行：
   a. 比较 `p1.val` 和 `p2.val`。
   b. 如果 `p1.val <= p2.val`，将 `p1` 连接到 `current.next`，然后 `p1 = p1.next`。
   c. 否则，将 `p2` 连接到 `current.next`，然后 `p2 = p2.next`。
   d. 移动 `current` 指针：`current = current.next`。
5. 循环结束后，如果 `p1` 还有剩余节点，将 `p1` 的剩余部分连接到 `current.next`。
6. 如果 `p2` 还有剩余节点，将 `p2` 的剩余部分连接到 `current.next`。
7. 返回 `dummy_head.next`。

**时间复杂度：** O(m + n) - 遍历两个链表一次。
**空间复杂度：** O(1) - 只使用了常数个额外变量（不考虑新链表本身的存储空间）。

## 代码实现

### Python
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(l1: ListNode, l2: ListNode) -> ListNode:
    """
    使用迭代法合并两个有序链表。
    """
    # 创建一个哑节点，简化头节点的处理
    dummy_head = ListNode(0)
    current = dummy_head # current 指针用于构建新链表
    
    # 遍历两个链表，直到其中一个遍历完
    while l1 and l2:
        if l1.val <= l2.val:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next # 移动 current 指针
        
    # 将剩余的链表部分直接连接到新链表末尾
    if l1:
        current.next = l1
    elif l2:
        current.next = l2
        
    return dummy_head.next # 返回新链表的头节点

```

## 关键点总结
1. **哑节点**：使用哑节点 `dummy_head` 是处理链表头节点操作的常用技巧，可以避免对空链表或第一个节点的特殊判断。
2. **双指针**：`l1` 和 `l2` 用于遍历两个输入链表，`current` 用于构建结果链表。
3. **迭代合并**：通过比较两个链表当前节点的值，将较小的节点连接到结果链表，并移动相应指针，直到一个链表为空。
4. **处理剩余部分**：当一个链表遍历完后，另一个链表可能还有剩余节点，直接将剩余部分连接到结果链表末尾即可。
