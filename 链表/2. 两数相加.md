# 2. 两数相加

## 题目描述
给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按 **逆序** 方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

## 示例
```
示例 1:
输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807.

示例 2:
输入: l1 = [0], l2 = [0]
输出: [0]

示例 3:
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
```

## 约束条件
- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零，除非该数字为 0 本身。

## 思考过程

### 🤔 第一步：理解问题
- 我们有两个链表，每个链表代表一个非负整数。
- 数字是**逆序**存储的，即个位在链表头，十位在第二个节点，以此类推。
- 我们需要将这两个数相加，并以同样逆序的链表形式返回结果。
- 每个节点只存储一位数字。

### 🤔 第二步：模拟加法过程
这就像我们小学学习的竖式加法。

**思考题：**
- 竖式加法需要考虑哪些因素？
- 链表如何模拟这个过程？

<details>
<summary>点击查看分析</summary>

- **从个位开始相加**：链表的头节点就是个位，这与逆序存储的特性完美匹配。
- **进位**：如果当前位的和大于等于 10，就需要向下一位（链表的下一个节点）进位。
- **处理不同长度的链表**：当一个链表遍历完后，另一个链表可能还有剩余，需要继续相加并考虑进位。
- **最终进位**：如果所有位都相加完毕，但还有进位，需要额外创建一个节点来存储这个进位。

</detaisl>

### 🤔 第三步：算法步骤总结
1. 创建一个哑节点 `dummy_head = ListNode(0)`，用于构建结果链表。
2. 创建一个 `current` 指针，指向 `dummy_head`。
3. 初始化 `carry = 0`，用于存储进位。
4. 使用 `p1 = l1`, `p2 = l2` 分别遍历两个输入链表。
5. 当 `p1` 或 `p2` 不为 `None`，或者 `carry` 不为 `0` 时，循环执行：
   a. 获取当前位的数字：`val1 = p1.val` (如果 `p1` 为 `None` 则为 0)，`val2 = p2.val` (如果 `p2` 为 `None` 则为 0)。
   b. 计算当前位的和：`sum_val = val1 + val2 + carry`。
   c. 计算当前位的新节点值：`digit = sum_val % 10`。
   d. 计算新的进位：`carry = sum_val // 10`。
   e. 创建新节点并连接：`current.next = ListNode(digit)`。
   f. 移动 `current` 指针：`current = current.next`。
   g. 移动 `p1` 和 `p2` 指针（如果它们不为 `None`）。
6. 循环结束后，返回 `dummy_head.next`。

**时间复杂度：** O(max(m, n)) - 遍历两个链表中最长的一个。
**空间复杂度：** O(max(m, n)) - 新链表的长度。

## 代码实现

### Python
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:
    """
    模拟竖式加法，将两个逆序存储的链表表示的数字相加。
    """
    dummy_head = ListNode(0) # 哑节点，用于构建结果链表
    current = dummy_head      # current 指针用于移动和连接新节点
    carry = 0                 # 进位
    
    # 循环条件：只要有一个链表还有节点，或者还有进位，就继续循环
    while l1 or l2 or carry:
        # 获取当前位的数字，如果链表已遍历完，则为 0
        val1 = l1.val if l1 else 0
        val2 = l2.val if l2 else 0
        
        # 计算当前位的和，包括进位
        sum_val = val1 + val2 + carry
        
        # 计算当前位的新节点值和新的进位
        digit = sum_val % 10
        carry = sum_val // 10
        
        # 创建新节点并连接到结果链表
        current.next = ListNode(digit)
        current = current.next
        
        # 移动 l1 和 l2 指针
        if l1:
            l1 = l1.next
        if l2:
            l2 = l2.next
            
    return dummy_head.next # 返回结果链表的头节点

```

## 关键点总结
1. **模拟竖式加法**：从低位（链表头）开始相加，并处理进位。
2. **哑节点**：简化了结果链表头部的处理，避免了对第一个节点的特殊判断。
3. **循环条件**：`while l1 or l2 or carry` 确保所有位都被处理，包括最后可能存在的进位。
4. **处理不同长度链表**：通过将已遍历完的链表的值视为 0，优雅地处理了两个链表长度不同的情况。
