# 142. 环形链表 II

## 题目描述
给定一个链表的头节点 `head` ，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表中节点的索引（从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识环的实际位置。

**不允许修改给定的链表。**

## 示例
```
示例 1:
输入: head = [3,2,0,-4], pos = 1
输出: 返回索引为 1 的链表节点
解释: 链表中有一个环，其尾部连接到第二个节点。

示例 2:
输入: head = [1,2], pos = 0
输出: 返回索引为 0 的链表节点
解释: 链表中有一个环，其尾部连接到第一个节点。

示例 3:
输入: head = [1], pos = -1
输出: 返回 null
解释: 链表中没有环。
```

## 约束条件
- 链表中节点的数目范围在 `[0, 10^4]` 内
- `-10^5 <= Node.val <= 10^5`
- `pos` 的值为 `-1` 或者链表中的一个 **有效索引** 。

## 思考过程

### 🤔 第一步：理解问题
- 我们需要找到链表开始入环的第一个节点。
- 如果没有环，返回 `None`。
- 不允许修改链表。

### 🤔 第二步：如何检测环？
这和 141 题一样，可以使用快慢指针（Floyd 判圈算法）。
- `slow` 每次走一步，`fast` 每次走两步。
- 如果 `slow` 和 `fast` 相遇，说明有环。
- 如果 `fast` 或 `fast.next` 走到 `None`，说明无环。

### 🤔 第三步：如何找到入环点？
这是本题的关键。当快慢指针相遇时，它们都在环内。如何从相遇点找到环的入口？

**数学推导：**
- 设链表头到环入口的距离为 `a`。
- 设环的长度为 `b`。
- 设相遇点距离环入口的距离为 `k`。

- `slow` 走过的距离：`a + k`
- `fast` 走过的距离：`a + k + n * b` (其中 `n` 是 `fast` 在环中多走的圈数)

因为 `fast` 的速度是 `slow` 的两倍，所以 `fast` 走过的距离是 `slow` 的两倍：
`2 * (a + k) = a + k + n * b`
`2a + 2k = a + k + n * b`
`a + k = n * b`
`a = n * b - k`
`a = (n - 1) * b + (b - k)`

这个公式告诉我们：
- 从链表头到环入口的距离 `a`。
- 从相遇点沿着环的方向走到环入口的距离 `b - k`。

**关键洞察：**
- 如果我们让一个指针从链表头开始，另一个指针从相遇点开始，它们都以每次一步的速度前进。
- 当它们相遇时，相遇点就是环的入口！

**为什么？**
- 从链表头到环入口的距离是 `a`。
- 从相遇点到环入口的距离是 `b - k`。
- 我们的推导 `a = (n - 1) * b + (b - k)` 表明，从链表头走 `a` 步，和从相遇点走 `b - k` 步（或者说 `(n-1)` 圈加上 `b-k` 步），它们最终都会到达环的入口。

### 🤔 第四步：算法步骤总结
1. **检测环**：
   - 使用快慢指针 `slow` 和 `fast`，都从 `head` 开始。
   - `slow` 每次走一步，`fast` 每次走两步。
   - 如果 `fast` 或 `fast.next` 变为 `None`，说明无环，返回 `None`。
   - 如果 `slow == fast`，说明有环，跳出循环。
2. **寻找入环点**：
   - 将 `slow` 指针重新指向 `head`。
   - 此时，`slow` 和 `fast` 都以每次一步的速度前进。
   - 当 `slow == fast` 时，它们相遇的节点就是环的入口。
3. 返回相遇的节点。

**时间复杂度：** O(n) - 快慢指针最多遍历链表两次。
**空间复杂度：** O(1) - 只使用了常数个额外变量。

## 代码实现

### Python
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def detectCycle(head: ListNode) -> ListNode:
    """
    使用快慢指针（Floyd 判圈算法）检测环并寻找入环点。
    """
    if not head or not head.next:
        return None
    
    slow = head
    fast = head
    
    # 1. 检测环：快慢指针相遇
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        
        if slow == fast:
            break # 相遇，存在环
    else:
        return None # fast 到达链表末尾，没有环
        
    # 2. 寻找入环点
    # 将 slow 重新指向 head
    # slow 和 fast 同时以一步的速度前进，相遇点即为环的入口
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next
        
    return slow # 返回环的入口节点

```

## 关键点总结
1. **环的检测**：与 141 题相同，使用快慢指针判断链表是否存在环。
2. **入环点的数学推导**：通过 `2 * (a + k) = a + k + n * b` 推导出 `a = (n - 1) * b + (b - k)`，这是找到入环点的理论基础。
3. **双指针策略**：当快慢指针相遇后，将其中一个指针（通常是 `slow`）重新指向链表头，然后两个指针都以一步的速度前进，它们再次相遇的节点就是环的入口。
