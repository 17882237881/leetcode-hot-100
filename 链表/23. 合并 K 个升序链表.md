# 23. 合并 K 个升序链表

## 题目描述
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，并返回合并后的链表。

## 示例
```
示例 1:
输入: lists = [[1,4,5],[1,3,4],[2,6]]
输出: [1,1,2,3,4,4,5,6]
解释: 链表数组如下:
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到:
1->1->2->3->4->4->5->6

示例 2:
输入: lists = []
输出: []

示例 3:
输入: lists = [[]]
输出: []
```

## 约束条件
- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `0 <= sum(lists[i].length) <= 10^4`
- `-10^4 <= Node.val <= 10^4`
- `lists[i]` 按升序排列

## 思考过程

### 🤔 第一步：理解问题
- 我们有 `k` 个已经排好序的链表。
- 需要将它们全部合并成一个大的、同样排好序的链表。
- 返回合并后的链表的头节点。

### 🤔 第二步：朴素解法（逐个合并）
最直观的想法是，我们可以重复使用“合并两个有序链表”的函数（21 题）。

**思考题：**
- 如果我们每次合并两个链表，总共需要合并多少次？
- 这个方法的时间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 假设每个链表的平均长度是 `N`。总共有 `k` 个链表。
- 第一次合并：两个链表，长度约 `2N`，时间 O(2N)。
- 第二次合并：结果链表（`2N`）和第三个链表（`N`），长度约 `3N`，时间 O(3N)。
- ...
- 第 `k-1` 次合并：结果链表（`(k-1)N`）和第 `k` 个链表（`N`），长度约 `kN`，时间 O(kN)。
- 总时间复杂度：O(2N + 3N + ... + kN) = O(N * (2 + 3 + ... + k)) = O(N * k²)。
- 对于 `k = 10^4`，`N = 500`，`k²` 达到 `10^8`，`N*k²` 更是天文数字，会超时。

</detaisl>

### 🤔 第三步：优化思路 - 分治法
逐个合并效率太低，因为每次合并的链表长度都在增加。我们可以借鉴归并排序的思想，使用分治法。

**核心思路：**
- 将 `k` 个链表分成两半，递归地合并左半部分和右半部分。
- 然后将合并后的两个大链表再合并起来。

**思考题：**
- 这种分治合并的时间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 假设总共有 `k` 个链表，每个链表平均长度为 `N`。总节点数 `TotalN = k * N`。
- 每次合并两个链表的时间复杂度是 O(链表总长度)。
- 整个过程可以看作一个二叉树，树的深度是 `log k`。
- 每一层合并操作的总时间复杂度都是 O(TotalN)。
- 所以总时间复杂度是 O(TotalN * log k) = O( (k * N) * log k)。
- 对于 `k = 10^4`，`N = 500`，`TotalN = 5 * 10^6`，`log k` 约等于 13。总操作数约 `5 * 10^6 * 13`，这是可以接受的。
- 空间复杂度：O(log k) - 递归栈的深度。

</detaisl>

### 🤔 第四步：最优解 - 最小堆（优先队列）
分治法已经很高效了，但还有一种更通用的方法，尤其适用于 `k` 很大的情况：使用最小堆（优先队列）。

**核心思路：**
- 最小堆可以帮助我们高效地找到所有链表当前头节点中的最小值。
- 我们将所有链表的头节点放入最小堆中。
- 每次从堆中取出最小的节点，将其添加到结果链表。
- 如果取出的节点还有下一个节点，就将下一个节点放入堆中。

**思考题：**
- 堆中存储什么？
- 堆操作的时间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 堆中存储的是 `(节点值, 节点)` 对。这样堆会根据节点值进行排序。
- 堆中最多会存储 `k` 个节点（每个链表一个）。
- 每次堆操作（插入、删除最小）的时间复杂度是 O(log k)。
- 总共有 `TotalN` 个节点需要处理，每个节点都会被插入和删除一次。
- 所以总时间复杂度是 O(TotalN * log k)。
- 空间复杂度：O(k) - 堆中最多存储 `k` 个节点。

</detaisl>

### 🤔 第五步：算法步骤总结（最小堆）
1. 导入 `heapq` 模块。
2. 创建一个哑节点 `dummy_head = ListNode(0)`，用于构建结果链表。
3. 创建一个最小堆 `min_heap`。
4. 将所有非空的链表的头节点放入堆中。堆中存储 `(node.val, index, node)`。`index` 是为了处理节点值相同的情况，确保元组可比较。
5. 当堆不为空时，循环执行：
   a. 从堆中取出最小的节点 `(val, index, node)`。
   b. 将 `node` 连接到结果链表：`current.next = node`，然后 `current = current.next`。
   c. 如果 `node.next` 不为 `None`，则将 `(node.next.val, new_index, node.next)` 放入堆中（`new_index` 递增）。
6. 返回 `dummy_head.next`。

**时间复杂度：** O(TotalN * log k) - `TotalN` 是所有链表中的总节点数。
**空间复杂度：** O(k) - 堆中最多存储 `k` 个节点。

## 代码实现

### Python
```python
import heapq

# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: list[ListNode]) -> ListNode:
    """
    使用最小堆（优先队列）合并 K 个升序链表。
    """
    dummy_head = ListNode(0) # 哑节点
    current = dummy_head      # 用于构建结果链表
    min_heap = []             # 最小堆
    
    # 为了处理节点值相同的情况，需要一个计数器来保证元组的唯一性
    # Python 的 heapq 在比较元组时，如果第一个元素相同，会比较第二个，以此类推
    # 如果节点本身不可比较，就会报错。所以加入一个递增的 index
    entry_index = 0 

    # 1. 将所有链表的头节点放入最小堆
    for head in lists:
        if head:
            heapq.heappush(min_heap, (head.val, entry_index, head))
            entry_index += 1
            
    # 2. 从堆中取出最小节点，并将其下一个节点放入堆中
    while min_heap:
        val, _, node = heapq.heappop(min_heap) # 取出最小节点
        
        current.next = node # 连接到结果链表
        current = current.next
        
        if node.next: # 如果当前节点还有下一个节点，则将其放入堆中
            heapq.heappush(min_heap, (node.next.val, entry_index, node.next))
            entry_index += 1
            
    return dummy_head.next

```

## 关键点总结
1. **最小堆**：是解决“从多个有序源中选择最小元素”问题的最佳数据结构。它能高效地在 `k` 个链表的当前头节点中找到最小值。
2. **哑节点**：简化了结果链表头部的处理。
3. **堆中存储内容**：存储 `(节点值, 唯一标识, 节点)` 的元组，确保堆能够正确比较和处理节点。
4. **时间复杂度**：O(TotalN * log k)，其中 `TotalN` 是所有链表的总节点数，`k` 是链表的数量。这是非常高效的解决方案。
