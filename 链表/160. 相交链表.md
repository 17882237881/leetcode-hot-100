# 160. 相交链表

## 题目描述
给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在任何交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

```
A:          a1 -> a2
                     \
                       c1 -> c2 -> c3
                     /
B:     b1 -> b2 -> b3
```

题目数据 保证 整个链式结构中不存在环。

**注意**：
- 如果两个链表没有交点，返回 `null`。
- 函数返回结果后，链表必须保持原样。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(m + n) 时间复杂度，且仅用 O(1) 内存。

## 示例
```
示例 1:
输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出: Intersected at '8'
解释: 相交节点的值为 8 （注意，如果两个链表相交则它们背后必然是同一条链表）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2:
输入: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Intersected at '2'
解释: 相交节点的值为 2 （注意，如果两个链表相交则它们背后必然是同一条链表）。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3:
输入: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出: No intersection
解释: 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以返回 null。
```

## 约束条件
- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `1 <= m, n <= 3 * 10^4`
- `0 <= Node.val <= 10^5`
- `skipA` 和 `skipB` 保证是有效的。

## 思考过程

### 🤔 第一步：理解问题
- 我们要找到两个单链表的第一个公共节点。
- 如果没有公共节点，返回 `None`。
- 链表没有环。
- 要求时间 O(m+n)，空间 O(1)。

### 🤔 第二步：朴素解法（哈希表）
最直观的想法是，遍历其中一个链表，将其所有节点存入一个哈希集合。然后遍历另一个链表，检查每个节点是否在哈希集合中。

**思考题：**
- 这个方法的时间和空间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 时间复杂度：O(m+n) - 遍历两个链表。
- 空间复杂度：O(m) 或 O(n) - 存储一个链表的节点。
- 满足时间要求，但不满足空间 O(1) 的要求。

</detaisl>

### 🤔 第三步：双指针法（O(1) 空间的关键）
既然不能用额外空间，我们只能利用链表本身的结构。两个链表可能长度不同，但如果它们相交，那么从相交点到链表末尾的这部分是**公共的**。

**核心思路：**
- 设链表 A 的长度为 `L_A`，链表 B 的长度为 `L_B`。
- 设相交点前的非公共部分长度分别为 `a` 和 `b`。
- 设公共部分的长度为 `c`。
- 那么 `L_A = a + c`，`L_B = b + c`。

我们让两个指针 `ptrA` 和 `ptrB` 分别从 `headA` 和 `headB` 开始遍历。

**思考题：**
- 如果 `ptrA` 走到了链表 A 的末尾，它应该去哪里？
- 如果 `ptrB` 走到了链表 B 的末尾，它应该去哪里？

<details>
<summary>点击查看分析</summary>

- 如果 `ptrA` 走到了链表 A 的末尾，让它从 `headB` 开始继续走。
- 如果 `ptrB` 走到了链表 B 的末尾，让它从 `headA` 开始继续走。

这样，当 `ptrA` 走完 `L_A` 步到达 A 的末尾后，它会跳到 `headB`，再走 `L_B` 步。总共走了 `L_A + L_B` 步。
同理，当 `ptrB` 走完 `L_B` 步到达 B 的末尾后，它会跳到 `headA`，再走 `L_A` 步。总共走了 `L_B + L_A` 步。

**关键点：**
- 如果两个链表相交，那么 `ptrA` 和 `ptrB` 最终会在相交点相遇。
- 如果两个链表不相交，那么 `ptrA` 和 `ptrB` 最终都会走到 `None`，并在 `None` 处相遇。

**证明：**
- `ptrA` 走过的路径长度：`a + c + b`
- `ptrB` 走过的路径长度：`b + c + a`

因为 `a + c + b == b + c + a`，所以如果它们相交，它们会在相等的路径长度后相遇在交点。如果它们不相交，它们会同时走到 `None`。

</detaisl>

### 🤔 第四步：算法步骤总结
1. 初始化两个指针 `ptrA = headA`, `ptrB = headB`。
2. 当 `ptrA != ptrB` 时，循环执行：
   a. 如果 `ptrA` 为 `None`，则 `ptrA = headB`；否则 `ptrA = ptrA.next`。
   b. 如果 `ptrB` 为 `None`，则 `ptrB = headA`；否则 `ptrB = ptrB.next`。
3. 循环结束后，`ptrA` (或 `ptrB`) 就是相交节点，或者 `None` (如果不相交)。

**时间复杂度：** O(m + n) - 两个指针最多走 `m + n` 步。
**空间复杂度：** O(1) - 只使用了常数个额外变量。

## 代码实现

### Python
```python
# Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def getIntersectionNode(headA: ListNode, headB: ListNode) -> ListNode:
    """
    使用双指针法寻找两个链表的相交节点。
    """
    if not headA or not headB:
        return None
    
    ptrA = headA
    ptrB = headB
    
    # 当 ptrA 和 ptrB 不相等时循环
    # 如果相交，它们会在交点相遇
    # 如果不相交，它们会同时走到 None
    while ptrA != ptrB:
        # 如果 ptrA 走到链表 A 的末尾，则从链表 B 的头部开始
        ptrA = ptrA.next if ptrA else headB
        
        # 如果 ptrB 走到链表 B 的末尾，则从链表 A 的头部开始
        ptrB = ptrB.next if ptrB else headA
        
    return ptrA # 此时 ptrA (或 ptrB) 就是相交节点或 None

```

## 关键点总结
1. **双指针交替遍历**：让两个指针分别从两个链表的头开始，当一个指针到达链表末尾时，切换到另一个链表的头部继续遍历。这种方式巧妙地抵消了两个链表长度的差异。
2. **等长路径**：无论链表是否相交，两个指针最终都会走过相同长度的路径。如果相交，它们会在交点相遇；如果不相交，它们会同时到达 `None`。
3. **O(1) 空间**：通过这种双指针策略，我们避免了使用额外的存储空间。

```