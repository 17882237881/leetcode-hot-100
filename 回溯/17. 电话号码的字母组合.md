**17. 电话号码的字母组合**

**思考过程:**

这道题是典型的回溯问题，需要生成所有可能的字母组合。我们可以将数字映射到相应的字母，然后通过递归的方式构建组合。

**核心思路:**

1.  **数字到字母的映射:** 首先，我们需要一个字典或哈希表来存储数字到字母的映射关系，例如 `{'2': 'abc', '3': 'def', ...}`。
2.  **回溯函数 `backtrack(index, current_combination)` 的设计:**
    -   **参数:**
        -   `index`: 当前正在处理的数字在 `digits` 字符串中的索引。
        -   `current_combination`: 当前已经构建的字母组合字符串。
    -   **终止条件:**
        -   如果 `index` 等于 `digits` 的长度，说明已经处理完所有数字，将 `current_combination` 添加到结果列表 `res` 中。
    -   **递归过程:**
        -   获取当前数字 `digit = digits[index]`。
        -   根据映射关系，获取 `digit` 对应的所有字母 `letters = mapping[digit]`。
        -   遍历 `letters` 中的每一个字母 `letter`：
            -   递归调用 `backtrack(index + 1, current_combination + letter)`。

**主函数逻辑:**

1.  初始化一个空列表 `res` 来存储所有结果。
2.  定义数字到字母的映射 `mapping`。
3.  如果输入的 `digits` 为空，直接返回空列表。
4.  调用 `backtrack(0, "")` 开始回溯过程。
5.  返回 `res`。

**Python 代码:**

```python
class Solution:
    def letterCombinations(self, digits: str) -> list[str]:
        if not digits:
            return []

        mapping = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }

        res = []

        def backtrack(index, current_combination):
            if index == len(digits):
                res.append(current_combination)
                return

            digit = digits[index]
            letters = mapping[digit]

            for letter in letters:
                backtrack(index + 1, current_combination + letter)

        backtrack(0, "")
        return res
```