# 64. 最小路径和

## 题目描述

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：** 每次只能向下或者向右移动一步。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

**提示：**

*   `m == grid.length`
*   `n == grid[i].length`
*   `1 <= m, n <= 200`
*   `0 <= grid[i][j] <= 100`

---

## 解题引导

### 思路：动态规划

**思考过程：**

这是一个典型的动态规划问题。我们要求从左上角到右下角的最小路径和。路径的每一步都只能向右或向下。

**状态定义：**
`dp[i][j]`：表示从左上角 `(0, 0)` 到达网格位置 `(i, j)` 的最小路径和。

**状态转移方程：**

要到达位置 `(i, j)`，我们只能从它的上方 `(i-1, j)` 或者左方 `(i, j-1)` 过来。

因此，到达 `(i, j)` 的最小路径和，就是从 `(i-1, j)` 过来的最小路径和与从 `(i, j-1)` 过来的最小路径和中的较小者，再加上当前位置 `grid[i][j]` 的值。

`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`

**边界条件：**

*   **第一行：** 对于第一行的任意位置 `(0, j)`，我们只能从左边过来。所以 `dp[0][j] = dp[0][j-1] + grid[0][j]`。
*   **第一列：** 对于第一列的任意位置 `(i, 0)`，我们只能从上边过来。所以 `dp[i][0] = dp[i-1][0] + grid[i][0]`。
*   **起点：** `dp[0][0] = grid[0][0]`。

**空间优化：**

我们可以发现，计算 `dp[i][j]` 只需要 `dp[i-1][j]` 和 `dp[i][j-1]` 的信息。这意味着我们实际上可以在原始的 `grid` 数组上直接进行修改，从而将空间复杂度优化到 `O(1)`（不考虑输入数据本身占用的空间）。

**算法流程（空间优化后）：**

1.  **初始化第一行：** 从第二个元素开始，`grid[0][j] = grid[0][j] + grid[0][j-1]`。
2.  **初始化第一列：** 从第二个元素开始，`grid[i][0] = grid[i][0] + grid[i-1][0]`。
3.  **遍历剩余部分：** 从 `(1, 1)` 开始遍历网格的其余部分。
    *   `grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]`。
4.  **返回结果：** 最终，右下角 `grid[m-1][n-1]` 的值就是从左上角到右下角的最小路径和。

**复杂度分析：**

*   **时间复杂度：** `O(m * n)`。我们需要遍历整个网格一次。
*   **空间复杂度：** `O(1)`。我们直接在输入数组上进行修改，没有使用额外的空间。

---

## Python 代码实现

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])

        # 初始化第一行
        for j in range(1, n):
            grid[0][j] += grid[0][j-1]

        # 初始化第一列
        for i in range(1, m):
            grid[i][0] += grid[i-1][0]

        # 遍历剩余的网格
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])

        return grid[m-1][n-1]

```