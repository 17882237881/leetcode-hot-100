# 62. 不同路径

## 题目描述

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

```
输入：m = 3, n = 7
输出：28
```

**示例 2：**

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

**示例 3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

**提示：**

*   `1 <= m, n <= 100`
*   题目数据保证答案小于等于 `2 * 10^9`

---

## 解题引导

### 思路：动态规划

**思考过程：**

这是一个经典的路径问题，非常适合用动态规划来解决。

机器人要到达网格中的任意一个点 `(i, j)`，它只能从两个方向过来：
1.  从它的上方，即 `(i-1, j)`，向下移动一步。
2.  从它的左方，即 `(i, j-1)`，向右移动一步。

因此，到达点 `(i, j)` 的总路径数，就等于到达点 `(i-1, j)` 的路径数与到达点 `(i, j-1)` 的路径数之和。

**状态定义：**
`dp[i][j]`：表示从左上角 `(0, 0)` 到达网格中点 `(i, j)` 的不同路径的总数。

**状态转移方程：**
`dp[i][j] = dp[i-1][j] + dp[i][j-1]`

**边界条件（初始化）：**

*   对于网格的第一行（`i = 0`），机器人只能一直向右走才能到达。所以，`dp[0][j] = 1` 对于所有的 `j`。
*   对于网格的第一列（`j = 0`），机器人只能一直向下走才能到达。所以，`dp[i][0] = 1` 对于所有的 `i`。
*   `dp[0][0]` 既是第一行也是第一列，值为 1。

**最终结果：**

我们要求的是到达右下角 `(m-1, n-1)` 的路径数，所以结果是 `dp[m-1][n-1]`。

**算法流程：**

1.  创建一个 `m x n` 的二维数组 `dp`。
2.  初始化第一行和第一列的所有值为 1。
3.  使用两层循环，从 `(1, 1)` 开始遍历到 `(m-1, n-1)`。
4.  在循环中，应用状态转移方程 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
5.  遍历结束后，返回 `dp[m-1][n-1]`。

**空间优化：**

注意到 `dp[i][j]` 的计算只依赖于当前行的左边元素和上一行的同一列元素。我们可以将二维 `dp` 数组压缩为一维数组。用一个大小为 `n` 的数组 `dp`，`dp[j]` 存储的是当前 `(i, j)` 位置的路径数。更新 `dp[j]` 时，`dp[j]` 的旧值代表 `dp[i-1][j]`，而 `dp[j-1]` 代表 `dp[i][j-1]`。所以转移方程变为 `dp[j] = dp[j] + dp[j-1]`。

**复杂度分析（优化后）：**

*   **时间复杂度：** `O(m * n)`。需要遍历整个网格。
*   **空间复杂度：** `O(n)`。使用了一维数组进行优化。

---

## Python 代码实现 (空间优化)

```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        # 使用一维数组进行空间优化
        # dp[j] 表示到达第 i 行第 j 列的路径数
        dp = [1] * n
        
        for i in range(1, m):
            for j in range(1, n):
                # dp[j] 的旧值是上一行的 dp[i-1][j]
                # dp[j-1] 是当前行的 dp[i][j-1]
                dp[j] = dp[j] + dp[j-1]
                
        return dp[n-1]

```