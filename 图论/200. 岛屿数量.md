# 200. 岛屿数量

## 题目描述
给你一个由 `'1'`（陆地）和 `'0'`（水）组成的数据 `grid` ，请你计算 `grid` 中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设 `grid` 的四条边均被水包围。

## 示例
```
示例 1:
输入: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出: 1

示例 2:
输入: grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出: 3
```

## 约束条件
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 为 `'0'` 或 `'1'`

## 思考过程

### 🤔 第一步：理解问题
- 我们有一个二维网格，由陆地（'1'）和水（'0'）组成。
- 岛屿是由水平或垂直方向相连的陆地组成的。
- 我们需要计算网格中有多少个独立的岛屿。

### 🤔 第二步：如何识别和计数岛屿？
想象一下，当你看到一个岛屿时，你会怎么做？你会从一个陆地开始，然后沿着所有相连的陆地走，直到把整个岛屿都“走遍”。走遍之后，这个岛屿就被“标记”了，下次再遇到它的一部分时，就知道它已经属于一个已知的岛屿了。

这正是图的遍历算法（DFS 或 BFS）的思路。

**核心思路：**
1. 遍历整个网格。
2. 每当遇到一个未访问过的陆地（'1'），就说明我们发现了一个新的岛屿。
3. 岛屿数量加一。
4. 然后，从这个陆地开始，使用 DFS 或 BFS 遍历所有与它相连的陆地，并将它们标记为已访问（例如，将其值改为 '0' 或 '2'），以避免重复计数。

### 🤔 第三步：深度优先搜索 (DFS)
DFS 是一种递归的遍历方式。

**DFS 辅助函数 `dfs(row, col)`：**
- **基本情况**：如果 `(row, col)` 超出网格边界，或者 `grid[row][col]` 是水（'0'），或者已经访问过（例如 '2'），则直接返回。
- **标记当前陆地**：将 `grid[row][col]` 标记为已访问（例如改为 '0'）。
- **递归探索相邻陆地**：对当前陆地的上、下、左、右四个方向的相邻陆地递归调用 `dfs`。

### 🤔 第四步：算法步骤总结
1. 初始化 `num_islands = 0`。
2. 获取网格的行数 `m` 和列数 `n`。
3. 遍历网格中的每一个单元格 `(i, j)`：
   a. 如果 `grid[i][j]` 是陆地（'1'）：
      i.   `num_islands` 加一。
      ii.  调用 `dfs(i, j)` 来淹没（标记）整个岛屿。
4. 返回 `num_islands`。

**时间复杂度：** O(m*n) - 每个单元格最多被访问一次。
**空间复杂度：** O(m*n) - 递归栈的深度，最坏情况下整个网格都是陆地。

## 代码实现

### Python
```python
def numIslands(grid: list[list[str]]) -> int:
    """
    使用深度优先搜索 (DFS) 计算岛屿数量。
    """
    if not grid or not grid[0]:
        return 0
    
    m, n = len(grid), len(grid[0])
    num_islands = 0
    
    # DFS 辅助函数，用于淹没（标记）整个岛屿
    def dfs(row, col):
        # 边界条件：超出网格范围，或者遇到水，或者已经访问过
        if not (0 <= row < m and 0 <= col < n) or grid[row][col] == '0':
            return
        
        # 标记当前陆地为已访问（将其变为 '0'，表示已淹没）
        grid[row][col] = '0'
        
        # 递归探索相邻的陆地
        dfs(row + 1, col) # 下
        dfs(row - 1, col) # 上
        dfs(row, col + 1) # 右
        dfs(row, col - 1) # 左

    # 遍历整个网格
    for i in range(m):
        for j in range(n):
            if grid[i][j] == '1':
                num_islands += 1 # 发现一个新岛屿
                dfs(i, j)        # 淹没整个岛屿
                
    return num_islands

```

## 关键点总结
1. **图的遍历**：将二维网格问题抽象为图的遍历问题，每个陆地单元格是节点，相邻陆地之间有边。
2. **DFS/BFS**：两种常用的图遍历算法都可以解决此问题。DFS 递归实现简洁，BFS 迭代实现更适合处理层级关系。
3. **原地标记**：通过修改 `grid` 中的值（例如将 '1' 改为 '0' 或 '2'），来标记已访问的陆地，避免重复计数和重复遍历。
4. **边界条件**：在递归或迭代中，需要仔细处理边界条件，确保不会越界。
