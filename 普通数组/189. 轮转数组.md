# 189. 轮转数组

## 题目描述
给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

## 示例
```
示例 1:
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释: 
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]

示例 2:
输入: nums = [-1,-100,3,99], k = 2
输出: [3,99,-1,-100]
解释: 
向右轮转 1 步: [99,-1,-100,3]
向右轮转 2 步: [3,99,-1,-100]
```

## 约束条件
- 1 <= nums.length <= 10^5
- -2^31 <= nums[i] <= 2^31 - 1
- 0 <= k <= 10^5

## 思考过程

### 🤔 第一步：理解问题
- 我们需要将数组 `nums` 中的元素向右移动 `k` 个位置。
- 移动是“轮转”的，这意味着末尾的元素会移动到开头。
- `k` 可以是非负数，并且可能大于数组的长度。

### 🤔 第二步：处理 `k` 的有效值
如果 `k` 大于 `nums` 的长度，那么实际上只需要移动 `k % len(nums)` 个位置。例如，长度为 7 的数组，向右轮转 7 步，相当于没有轮转；向右轮转 10 步，相当于向右轮转 3 步。

所以，首先将 `k = k % len(nums)`。

### 🤔 第三步：暴力解法（额外数组）
最直观的方法是创建一个新的数组，然后将原数组的元素按照轮转后的顺序放入新数组。

**思考题：**
- 如何确定每个元素在新数组中的位置？
- 这个方法的时间和空间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 对于原数组中的 `nums[i]`，它在新数组中的位置是 `(i + k) % n`。
- 时间复杂度：O(n) - 遍历一次原数组，遍历一次新数组。
- 空间复杂度：O(n) - 需要一个额外的数组。

</details>

### 🤔 第四步：原地解法（多次反转）
题目通常会要求原地操作，即空间复杂度为 O(1)。

考虑一个数组 `[1,2,3,4,5,6,7]`，`k = 3`。
目标是 `[5,6,7,1,2,3,4]`。

我们可以观察到，轮转后，数组被分成了两部分：
- 后 `k` 个元素 `[5,6,7]` 移动到了前面。
- 前 `n-k` 个元素 `[1,2,3,4]` 移动到了后面。

这启发我们使用**三次反转**的方法：
1. **反转整个数组**：`[7,6,5,4,3,2,1]`
2. **反转前 `k` 个元素**：`[5,6,7,4,3,2,1]` (即 `[7,6,5]` 反转为 `[5,6,7]`)。
3. **反转后 `n-k` 个元素**：`[5,6,7,1,2,3,4]` (即 `[4,3,2,1]` 反转为 `[1,2,3,4]`)。

**思考题：** 为什么这个方法有效？

<details>
<summary>点击查看分析</summary>

- 假设数组为 `A + B`，其中 `A` 是前 `n-k` 个元素，`B` 是后 `k` 个元素。
- 目标是 `B + A`。
- 1. 反转整个数组：`(A + B)` 反转为 `(B_rev + A_rev)`，其中 `B_rev` 是 `B` 的反转，`A_rev` 是 `A` 的反转。
- 2. 反转前 `k` 个元素：`B_rev` 反转为 `B`。现在数组是 `B + A_rev`。
- 3. 反转后 `n-k` 个元素：`A_rev` 反转为 `A`。现在数组是 `B + A`。

</detaisl>

### 🤔 第五步：算法步骤总结（三次反转）
1. 计算有效的轮转步数 `k = k % len(nums)`。
2. 定义一个辅助函数 `reverse(arr, start, end)`，用于反转数组 `arr` 中从 `start` 到 `end`（包含）的元素。
3. **第一次反转**：反转整个数组 `nums`，即 `reverse(nums, 0, n-1)`。
4. **第二次反转**：反转前 `k` 个元素，即 `reverse(nums, 0, k-1)`。
5. **第三次反转**：反转后 `n-k` 个元素，即 `reverse(nums, k, n-1)`。

**时间复杂度：** O(n) - 每次反转都是 O(n)，总共三次。
**空间复杂度：** O(1) - 原地操作。

## 代码实现

### Python
```python
def rotate(nums: list[int], k: int) -> None:
    """
    使用三次反转法原地轮转数组。
    Do not return anything, modify nums in-place instead.
    """
    n = len(nums)
    k = k % n  # 处理 k 大于 n 的情况
    
    # 辅助函数：反转数组的一部分
    def reverse(arr, start, end):
        while start < end:
            arr[start], arr[end] = arr[end], arr[start]
            start += 1
            end -= 1
            
    # 1. 反转整个数组
    reverse(nums, 0, n - 1)
    
    # 2. 反转前 k 个元素
    reverse(nums, 0, k - 1)
    
    # 3. 反转后 n-k 个元素
    reverse(nums, k, n - 1)

```

## 关键点总结
1. **`k` 的有效值**：首先对 `k` 取模，确保 `k` 在有效范围内。
2. **三次反转**：这是一个非常巧妙且高效的原地轮转数组的方法，将数组的两个部分分别反转，再整体反转，最终达到轮转的效果。
3. **原地操作**：通过直接修改原数组，避免了额外的空间开销，满足了题目对空间复杂度的要求。
