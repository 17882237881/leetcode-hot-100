# 41. 缺失的第一个正数

## 题目描述
给你一个未排序的整数数组 `nums`，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

## 示例
```
示例 1:
输入: nums = [1,2,0]
输出: 3

示例 2:
输入: nums = [3,4,-1,1]
输出: 2

示例 3:
输入: nums = [7,8,9,11,12]
输出: 1
```

## 约束条件
- 1 <= nums.length <= 5 * 10^5
- -2^31 <= nums[i] <= 2^31 - 1

## 思考过程

### 🤔 第一步：理解问题
- 我们要找的是数组中**没有出现**的**最小的正整数**。
- 数组是**未排序**的。
- 关键限制：时间复杂度 `O(n)`，空间复杂度 `O(1)`。

### 🤔 第二步：初步分析与排除法
- **正整数**：这意味着我们只关心大于 0 的数。负数和 0 都可以忽略。
- **最小的正整数**：如果数组中有 1，那么答案可能是 2 或更大；如果没有 1，那么答案就是 1。
- **数组长度 `n`**：如果数组长度为 `n`，那么我们关心的正整数范围是 `[1, n+1]`。为什么是 `n+1`？因为如果 `1` 到 `n` 都出现了，那么最小的缺失正整数就是 `n+1`。

### 🤔 第三步：暴力解法（排序或哈希表）
- **排序**：先对数组排序，然后从 1 开始遍历，看哪个正整数没有出现。时间复杂度 O(n log n)，不满足 O(n)。
- **哈希表/集合**：将所有正整数存入哈希集合，然后从 1 开始遍历，看哪个正整数不在集合中。时间复杂度 O(n)，空间复杂度 O(n)，不满足 O(1)。

### 🤔 第四步：原地哈希（O(1) 空间的关键）
既然不能用额外空间，我们只能利用原数组的空间。如何利用？

**核心思想：**
- 我们可以尝试将数字 `x` 放到它“应该在”的位置 `x-1` 上。
- 例如，如果 `nums[i] = 1`，我们就把它放到 `nums[0]` 的位置。
- 如果 `nums[i] = 2`，我们就把它放到 `nums[1]` 的位置。

**具体操作：**
遍历数组 `nums`。对于每个 `nums[i]`：
- 如果 `nums[i]` 是一个正数，并且在 `[1, n]` 的范围内。
- 并且 `nums[i]` 不在它“应该在”的位置上（即 `nums[i] != nums[nums[i]-1]`）。
- 那么，我们就交换 `nums[i]` 和 `nums[nums[i]-1]`。
- 这个过程需要持续进行，直到 `nums[i]` 归位，或者 `nums[i]` 不符合条件（负数、0、超出范围）。

**思考题：**
- 为什么只关心 `[1, n]` 范围内的正整数？
- 交换操作如何保证时间复杂度是 O(n)？

<details>
<summary>点击查看分析</summary>

- **范围 `[1, n]`**：如果缺失的最小正整数大于 `n`，那么 `1` 到 `n` 肯定都存在于数组中。在这种情况下，答案就是 `n+1`。所以我们只需要关注 `1` 到 `n` 这些数字。
- **时间复杂度**：虽然有 `while` 循环，但每个数字最多被交换两次（一次从错误位置移出，一次移到正确位置），所以总的交换次数是 O(n)。因此，整个过程的时间复杂度是 O(n)。

</detaisl>

### 🤔 第五步：算法步骤总结
1. 获取数组长度 `n = len(nums)`。
2. **原地调整**：遍历数组 `nums`，索引 `i` 从 `0` 到 `n-1`：
   a. 使用一个 `while` 循环：
      i.  条件 1：`nums[i] > 0` (必须是正数)
      ii. 条件 2：`nums[i] <= n` (必须在 `[1, n]` 范围内)
      iii. 条件 3：`nums[i] != nums[nums[i]-1]` (当前数字不在它应该在的位置上)
   b. 如果以上三个条件都满足，则交换 `nums[i]` 和 `nums[nums[i]-1]`。
   c. 如果不满足，或者交换后 `nums[i]` 已经归位，则跳出 `while` 循环，处理下一个 `i`。
3. **查找缺失**：再次遍历调整后的数组 `nums`，索引 `i` 从 `0` 到 `n-1`：
   a. 如果 `nums[i] != i + 1`，说明 `i + 1` 这个正整数缺失了，返回 `i + 1`。
4. 如果遍历完整个数组，所有 `nums[i]` 都等于 `i + 1`，说明 `1` 到 `n` 都存在，那么缺失的最小正整数就是 `n + 1`，返回 `n + 1`。

**时间复杂度：** O(n) - 两次遍历，加上内部的交换操作均摊 O(n)。
**空间复杂度：** O(1) - 原地修改数组。

## 代码实现

### Python
```python
def firstMissingPositive(nums: list[int]) -> int:
    """
    使用原地哈希（交换法）寻找缺失的第一个正数。
    """
    n = len(nums)
    
    # 1. 将数字放到其“应该在”的位置上
    # 例如，1 放到索引 0，2 放到索引 1，以此类推
    for i in range(n):
        # 循环条件：
        # 1. nums[i] 必须是正数
        # 2. nums[i] 必须在 [1, n] 的范围内
        # 3. nums[i] 不在它应该在的位置上 (即 nums[i] != nums[nums[i]-1])
        while 1 <= nums[i] <= n and nums[i] != nums[nums[i]-1]:
            # 交换 nums[i] 和 nums[nums[i]-1]
            # temp_idx 是 nums[i] 应该去的位置
            temp_idx = nums[i] - 1
            nums[i], nums[temp_idx] = nums[temp_idx], nums[i]
            
    # 2. 查找第一个不符合“nums[i] == i + 1”的位置
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
            
    # 3. 如果 1 到 n 都存在，那么缺失的第一个正数就是 n + 1
    return n + 1

```

## 关键点总结
1. **原地哈希**：利用数组本身的索引作为哈希表的键，将数字放到其对应的位置上，从而实现 O(1) 的空间复杂度。
2. **有效范围**：只关注 `[1, n]` 范围内的正整数，因为其他数字对结果没有影响。
3. **循环交换**：内部的 `while` 循环确保每个数字都被正确地放置或被忽略。虽然是循环，但每个数字最多被交换两次，所以总时间复杂度是 O(n)。
4. **最终查找**：在调整后的数组中，第一个 `nums[i] != i + 1` 的位置 `i`，就意味着 `i + 1` 是缺失的第一个正数。
