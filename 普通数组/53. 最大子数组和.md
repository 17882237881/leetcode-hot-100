# 53. 最大子数组和

## 题目描述
给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

## 示例
```
示例 1:
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

示例 2:
输入: nums = [1]
输出: 1

示例 3:
输入: nums = [5,4,-1,7,8]
输出: 23
```

## 约束条件
- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4

## 思考过程

### 🤔 第一步：理解问题
- 我们要找的是一个**连续**的子数组。
- 这个子数组的和必须是所有连续子数组中**最大**的。
- 子数组至少包含一个元素。
- 数组中可能包含负数。

### 🤔 第二步：暴力解法
最直接的想法是，找出所有可能的连续子数组，计算它们的和，然后找到最大的那个。

**思考题：**
- 如何用循环实现找到所有连续子数组？
- 这个方法的时间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 可以用两层循环。外层循环 `i` 固定子数组的起点，内层循环 `j` 固定子数组的终点。
- 对于每个子数组 `nums[i:j+1]`，再求和。
- 如果每次都重新求和，时间复杂度是 O(n³)。如果内层循环中累加和，可以优化到 O(n²)。
- 对于 `n <= 10^5`，O(n²) 依然太慢，会超时。

</details>

### 🤔 第三步：动态规划
O(n²) 太慢，我们需要更高效的方法。这个问题具有“最优子结构”和“重叠子问题”的特点，这提示我们可以使用动态规划。

**定义 `dp[i]`：**
`dp[i]` 表示以 `nums[i]` **结尾**的连续子数组的最大和。

**思考题：**
- `dp[i]` 和 `dp[i-1]` 之间有什么关系？
- 如何推导出状态转移方程？

<details>
<summary>点击查看分析</summary>

以 `nums[i]` 结尾的连续子数组的最大和，有两种可能：
1. 这个子数组只包含 `nums[i]` 一个元素。
2. 这个子数组包含 `nums[i]`，并且它连接了以 `nums[i-1]` 结尾的最大子数组。

所以，`dp[i] = max(nums[i], dp[i-1] + nums[i])`。

**初始状态：** `dp[0] = nums[0]`。

**最终结果：** 整个 `dp` 数组中的最大值就是我们要找的答案。

</details>

### 🤔 第四步：动态规划算法步骤
1. 创建一个 `dp` 数组，大小与 `nums` 相同。
2. 初始化 `dp[0] = nums[0]`。
3. 初始化 `max_sum = nums[0]`，用于记录全局最大和。
4. 从 `i = 1` 到 `n-1` 遍历 `nums`：
   a. `dp[i] = max(nums[i], dp[i-1] + nums[i])`。
   b. `max_sum = max(max_sum, dp[i])`。
5. 返回 `max_sum`。

**时间复杂度：** O(n) - 只遍历一次数组。
**空间复杂度：** O(n) - 使用了一个 `dp` 数组。

### 🤔 第五步：空间优化（Kadane's Algorithm）
观察状态转移方程 `dp[i] = max(nums[i], dp[i-1] + nums[i])`，我们发现 `dp[i]` 的计算只依赖于 `dp[i-1]`。这意味着我们不需要整个 `dp` 数组，只需要一个变量来存储前一个 `dp` 值即可。

**算法流程：**
1. 初始化 `current_max = nums[0]` (表示以当前元素结尾的最大和)。
2. 初始化 `global_max = nums[0]` (表示全局最大和)。
3. 从 `i = 1` 到 `n-1` 遍历 `nums`：
   a. `current_max = max(nums[i], current_max + nums[i])`。
   b. `global_max = max(global_max, current_max)`。
4. 返回 `global_max`。

**时间复杂度：** O(n) - 依然只遍历一次数组。
**空间复杂度：** O(1) - 只使用了常数个额外变量。

这就是著名的 **Kadane's Algorithm**。

## 代码实现

### Python
```python
def maxSubArray(nums: list[int]) -> int:
    """
    使用 Kadane's Algorithm 寻找最大子数组和。
    """
    if not nums:
        return 0
    
    current_max = nums[0]  # 以当前元素结尾的最大和
    global_max = nums[0]   # 全局最大和
    
    for i in range(1, len(nums)):
        # 决定以 nums[i] 结尾的最大和：
        # 1. 只包含 nums[i] 本身
        # 2. 包含 nums[i] 和前面连续子数组的最大和
        current_max = max(nums[i], current_max + nums[i])
        
        # 更新全局最大和
        global_max = max(global_max, current_max)
        
    return global_max

```

## 关键点总结
1. **动态规划思想**：将问题分解为子问题，并利用子问题的解来构建原问题的解。
2. **Kadane's Algorithm**：一个非常经典的动态规划优化，将空间复杂度从 O(n) 降到 O(1)。
3. **`current_max` 的含义**：它始终代表着“以当前遍历到的元素为结尾的连续子数组的最大和”。如果 `current_max` 加上当前元素后变得更小，甚至小于当前元素本身，那就说明之前的子数组对当前元素是“拖累”，不如从当前元素重新开始一个子数组。
