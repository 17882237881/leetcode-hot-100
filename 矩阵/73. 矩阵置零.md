# 73. 矩阵置零

## 题目描述
给定一个 `m x n` 的矩阵，如果一个元素为 `0` ，则将其所在行和列的所有元素都设为 `0` 。请使用 **原地** 算法。

## 示例
```
示例 1:
输入: matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出: [[1,0,1],[0,0,0],[1,0,1]]

示例 2:
输入: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
输出: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
```

## 约束条件
- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-2^31 <= matrix[i][j] <= 2^31 - 1`

## 思考过程

### 🤔 第一步：理解问题
- 我们有一个 `m x n` 的矩阵。
- 如果矩阵中的某个元素是 `0`，那么它所在的**整行**和**整列**都要被置为 `0`。
- 必须使用**原地算法**，这意味着不能使用额外的矩阵来存储结果。

### 🤔 第二步：朴素解法（额外空间）
最直观的想法是，先遍历一遍矩阵，记录所有 `0` 的位置。然后，再遍历一遍矩阵，根据记录的位置将对应的行和列置为 `0`。

**思考题：**
- 如何记录 `0` 的位置？
- 这个方法的时间和空间复杂度是多少？

<details>
<summary>点击查看分析</summary>

- 可以使用两个布尔数组 `row_zero[m]` 和 `col_zero[n]`，分别记录哪些行和列需要置零。
- 第一次遍历：O(m*n) 填充 `row_zero` 和 `col_zero`。
- 第二次遍历：O(m*n) 根据 `row_zero` 和 `col_zero` 置零。
- 时间复杂度：O(m*n)。
- 空间复杂度：O(m + n) - 两个布尔数组。

</details>

### 🤔 第三步：原地算法的挑战
题目要求原地算法，即空间复杂度为 O(1)。这意味着我们不能使用额外的 `O(m+n)` 空间来记录需要置零的行和列。

**思考题：**
- 如果我们直接在原矩阵上置零，会发生什么问题？

<details>
<summary>点击查看分析</summary>

- 如果我们直接在遍历过程中遇到 `0` 就置零，那么这个 `0` 会导致它所在的行和列都变成 `0`。这些新产生的 `0` 又会影响到其他行和列，导致“连锁反应”，最终可能把整个矩阵都置为 `0`，这不是我们想要的。
- 我们需要一种方法来“标记”哪些行和列需要置零，但又不能影响到后续的判断。

</detaisl>

### 🤔 第四步：利用第一行/列作为标记
既然不能用额外的 `O(m+n)` 空间，那我们能不能利用矩阵本身的空间呢？

**核心思路：**
- 我们可以将第一行和第一列作为“标记”数组。
- 如果 `matrix[i][j]` 为 `0`，我们就将 `matrix[i][0]` 和 `matrix[0][j]` 置为 `0`。

**思考题：**
- 这种方法有什么潜在的问题？
- 如何解决第一行和第一列本身可能包含 `0` 的情况？

<details>
<summary>点击查看分析</summary>

- **问题**：如果 `matrix[0][0]` 本身就是 `0`，那么它既是第一行的标记，也是第一列的标记。这会导致混淆。
- **解决方案**：我们需要一个额外的变量来记录第一列是否需要置零。第一行可以直接用 `matrix[0][0]` 作为标记。

</detaisl>

### 🤔 第五步：算法步骤总结（O(1) 空间）
1. **检查第一列是否需要置零**：
   - 用一个布尔变量 `col0_has_zero` 记录第一列是否有 `0`。
   - 遍历第一列，如果遇到 `matrix[i][0] == 0`，则将 `col0_has_zero` 设为 `True`。
2. **使用第一行/列作为标记**：
   - 从 `matrix[0][1]` 开始遍历矩阵（跳过第一列）。
   - 如果 `matrix[i][j] == 0`，则将 `matrix[i][0]` 和 `matrix[0][j]` 置为 `0`。
3. **根据标记置零（从后往前）**：
   - 从 `matrix[m-1][n-1]` 开始，**从下往上，从右往左**遍历矩阵（跳过第一行和第一列）。
   - 如果 `matrix[i][0] == 0` 或者 `matrix[0][j] == 0`，则将 `matrix[i][j]` 置为 `0`。
   - **为什么从后往前？** 这样可以避免在置零过程中，将原本不是 `0` 的标记位也置为 `0`，从而影响后续的判断。
4. **处理第一行**：
   - 如果 `matrix[0][0] == 0`，则将第一行所有元素置为 `0`。
5. **处理第一列**：
   - 如果 `col0_has_zero` 为 `True`，则将第一列所有元素置为 `0`。

**时间复杂度：** O(m*n) - 几次遍历。
**空间复杂度：** O(1) - 只使用了一个布尔变量。

## 代码实现

### Python
```python
def setZeroes(matrix: list[list[int]]) -> None:
    """
    使用第一行/列作为标记，实现 O(1) 空间复杂度的矩阵置零。
    Do not return anything, modify matrix in-place instead.
    """
    m, n = len(matrix), len(matrix[0])
    col0_has_zero = False
    
    # 1. 检查第一列是否有 0，并用第一行/列作为标记
    for i in range(m):
        if matrix[i][0] == 0:
            col0_has_zero = True
        
        # 从第二列开始遍历，如果遇到 0，则标记对应的行和列
        for j in range(1, n):
            if matrix[i][j] == 0:
                matrix[i][0] = 0  # 标记行
                matrix[0][j] = 0  # 标记列
                
    # 2. 根据标记，从后往前置零（避免影响标记位）
    # 注意：这里从 m-1 开始，到 0 结束，步长为 -1
    for i in range(m - 1, -1, -1):
        # 注意：这里从 n-1 开始，到 1 结束，步长为 -1
        for j in range(n - 1, 0, -1):
            if matrix[i][0] == 0 or matrix[0][j] == 0:
                matrix[i][j] = 0
        
        # 3. 最后处理第一列（根据 col0_has_zero 标记）
        if col0_has_zero:
            matrix[i][0] = 0

```

## 关键点总结
1. **原地标记**：利用矩阵的第一行和第一列作为标记空间，是实现 O(1) 空间复杂度的核心。
2. **特殊处理第一列**：由于 `matrix[0][0]` 同时作为第一行和第一列的标记，需要一个额外的布尔变量来独立记录第一列是否需要置零。
3. **倒序遍历**：在根据标记置零时，从矩阵的右下角开始，向左上角遍历，可以避免在置零过程中，将原本不是 `0` 的标记位也置为 `0`，从而影响后续的判断。
