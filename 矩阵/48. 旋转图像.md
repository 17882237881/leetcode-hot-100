# 48. 旋转图像

## 题目描述
给定一个 `n × n` 的二维矩阵表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 **原地** 旋转图像，这意味着你不能使用另一个二维矩阵来旋转图像。请你直接修改输入的二维矩阵。

## 示例
```
示例 1:
输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出: [[7,4,1],[8,5,2],[9,6,3]]

示例 2:
输入: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,18,16]]
输出: [[15,13,2,5],[14,3,4,1],[18,6,8,9],[16,7,10,11]]
```

## 约束条件
- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

## 思考过程

### 🤔 第一步：理解问题
- 我们有一个 `n x n` 的正方形矩阵。
- 需要将其顺时针旋转 90 度。
- 必须**原地**旋转，不能使用额外的矩阵。

### 🤔 第二步：观察旋转规律
让我们以 `[[1,2,3],[4,5,6],[7,8,9]]` 为例，旋转后变为 `[[7,4,1],[8,5,2],[9,6,3]]`。

观察元素位置的变化：
- `matrix[0][0]` (1) -> `matrix[0][2]` (3) -> `matrix[2][2]` (9) -> `matrix[2][0]` (7) -> `matrix[0][0]` (1)
- `matrix[i][j]` 旋转后会到哪里？

**思考题：** `matrix[row][col]` 旋转 90 度后，它的新位置 `matrix[new_row][new_col]` 是什么？

<details>
<summary>点击查看分析</summary>

- `matrix[row][col]` 旋转 90 度后，会移动到 `matrix[col][n - 1 - row]`。
- 例如，`matrix[0][0]` (1) 移动到 `matrix[0][2]` (3) 的位置，即 `matrix[0][3-1-0] = matrix[0][2]`。
- `matrix[0][1]` (2) 移动到 `matrix[1][2]` (6) 的位置，即 `matrix[1][3-1-0] = matrix[1][2]`。

</detaisl>

### 🤔 第三步：原地旋转的挑战
如果我们直接按照 `matrix[row][col] -> matrix[col][n - 1 - row]` 的规则进行赋值，会覆盖掉原始数据，导致后续的旋转无法进行。

**思考题：** 如何在原地完成旋转？

<details>
<summary>点击查看分析</summary>

- 我们可以考虑**分步旋转**。
- **方法一：四角交换**：每次处理四个相互关联的元素。
- **方法二：先转置再反转**：
    1. **转置**（主对角线翻转）：`matrix[i][j]` 和 `matrix[j][i]` 交换。
    2. **反转每一行**：将每一行左右反转。

</detaisl>

### 🤔 第四步：方法二：先转置再反转（推荐）
这个方法更直观，也更容易实现。

1. **转置 (Transpose)**：
   - 将矩阵沿着主对角线（从左上到右下）进行翻转。
   - 也就是将 `matrix[i][j]` 和 `matrix[j][i]` 进行交换。
   - 只需要遍历矩阵的**上半部分**（或下半部分），避免重复交换。
   - 遍历 `i` 从 `0` 到 `n-1`，`j` 从 `i+1` 到 `n-1`。

   例如 `[[1,2,3],[4,5,6],[7,8,9]]` 转置后变为 `[[1,4,7],[2,5,8],[3,6,9]]`。

2. **反转每一行 (Reverse each row)**：
   - 将转置后的矩阵的每一行进行左右反转。
   - 也就是将 `matrix[i][j]` 和 `matrix[i][n-1-j]` 进行交换。

   例如 `[[1,4,7],[2,5,8],[3,6,9]]` 反转每一行后变为 `[[7,4,1],[8,5,2],[9,6,3]]`。

**思考题：** 为什么“先转置再反转每一行”能实现顺时针 90 度旋转？

<details>
<summary>点击查看分析</summary>

- 原始位置 `(row, col)`
- 转置后：`(col, row)`
- 反转每一行后：`(col, n - 1 - row)`
- 这正是我们之前推导出的顺时针 90 度旋转后的新位置。

</detaisl>

### 🤔 第五步：算法步骤总结
1. 获取矩阵的维度 `n = len(matrix)`。
2. **第一步：转置矩阵**
   - 遍历 `i` 从 `0` 到 `n-1`。
   - 遍历 `j` 从 `i+1` 到 `n-1`。
   - 交换 `matrix[i][j]` 和 `matrix[j][i]`。
3. **第二步：反转每一行**
   - 遍历 `i` 从 `0` 到 `n-1` (每一行)。
   - 对 `matrix[i]` 这一行进行左右反转（可以使用双指针 `left` 和 `right`）。

**时间复杂度：** O(n²) - 两次遍历矩阵。
**空间复杂度：** O(1) - 原地操作。

## 代码实现

### Python
```python
def rotate(matrix: list[list[int]]) -> None:
    """
    先转置再反转每一行，实现矩阵顺时针 90 度原地旋转。
    Do not return anything, modify matrix in-place instead.
    """
    n = len(matrix)
    
    # 1. 转置矩阵 (主对角线翻转)
    for i in range(n):
        for j in range(i + 1, n):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
            
    # 2. 反转每一行
    for i in range(n):
        # 对当前行进行左右反转
        left, right = 0, n - 1
        while left < right:
            matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]
            left += 1
            right -= 1

```

## 关键点总结
1. **分解问题**：将复杂的 90 度旋转分解为两个简单的操作：转置和反转每一行。
2. **原地操作**：通过直接修改矩阵元素，避免了额外的空间开销。
3. **转置的遍历范围**：转置时只需要遍历矩阵的对角线以上（或以下）的部分，避免重复交换。
