# 347. 前 K 个高频元素

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**示例 2:**

```
输入: nums = [1], k = 1
输出: [1]
```

**提示：**

*   `1 <= nums.length <= 10^5`
*   `k` 在 `[1, 数组中不同元素的个数]` 范围内
*   题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：** 你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组的大小。

---

## 解题引导

### 思路：哈希表 + 最小堆

**思考过程：**

这个问题要求我们找到出现频率最高的 k 个元素。我们可以分两步解决：

1.  **统计频率：** 首先，我们需要统计数组中每个元素出现的频率。哈希表（在 Python 中是字典）是完成这个任务的理想数据结构。
2.  **找出前 k 高频：** 在得到频率后，问题就变成了“如何从一组（元素，频率）对中找出频率最高的前 k 个”。这和“数组中的第K个最大元素”非常相似。我们可以使用一个大小为 k 的最小堆来解决。

**算法流程：**

1.  使用哈希表 `counts` 统计 `nums` 中每个元素的出现频率。
2.  创建一个最小堆 `min_heap`。堆中存储的是一个元组 `(频率, 元素)`。
3.  遍历 `counts` 哈希表中的每个 `(元素, 频率)` 对：
    *   如果堆的大小小于 `k`，直接将 `(频率, 元素)` 推入堆中。
    *   如果堆的大小等于 `k`，将当前元素的频率与堆顶元素的频率（也就是当前堆中 k 个元素里频率最小的）进行比较。
        *   如果当前频率大于堆顶频率，则弹出堆顶元素，并将新的 `(频率, 元素)` 推入堆中。
        *   否则，不进行任何操作。
4.  遍历结束后，堆中剩下的 `k` 个元素就是频率最高的前 `k` 个元素。将它们从堆中取出并返回。

**复杂度分析：**

*   **时间复杂度：** `O(n log k)`。
    *   统计频率需要 `O(n)`。
    *   遍历哈希表中的 `m` 个不同元素（`m <= n`），并将它们与堆进行比较。每次堆操作的时间复杂度是 `O(log k)`，总共是 `O(m log k)`。
    *   因此，总的时间复杂度是 `O(n + m log k)`。在最坏的情况下 `m` 接近 `n`，所以是 `O(n log k)`。
*   **空间复杂度：** `O(m + k)`。
    *   哈希表需要 `O(m)` 的空间来存储 `m` 个不同元素。
    *   堆需要 `O(k)` 的空间。

---

## Python 代码实现

```python
from typing import List
import collections
import heapq

class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        # 1. 统计元素出现频率
        counts = collections.Counter(nums)
        
        # 2. 使用最小堆找出频率前 k 高的元素
        min_heap = []
        for num, freq in counts.items():
            if len(min_heap) < k:
                heapq.heappush(min_heap, (freq, num))
            elif freq > min_heap[0][0]:
                heapq.heapreplace(min_heap, (freq, num))
                
        # 3. 返回结果
        return [item[1] for item in min_heap]

```